\chapter{Memoizing hole instance numbering using environments}
\label{sec:renumbering}

\section{Rationale behind hole instances and unique hole closures}
\label{sec:instance-illustration}

Consider the program displayed in \Cref{fig:instance-illustration}. The evaluation result of the program is \[
  [a\leftarrow[\varnothing]\hehole^1,x\leftarrow 3]\hehole^2
  + [a\leftarrow[\varnothing]\hehole^1,x\leftarrow 4]\hehole^2
\] Note that the two instances of \heh2 have different environments, and we thus distinguish between the two occurrences of \heh2 as separate \textbf{instances} of a hole. However, note that while there are also two instances of the hole \heh1 in the result, these share the same (physically equal) environment. No matter what expression we fill hole \heh1 with (for example, using the fill-and-resume operation) the hole will evaluate to the same value. This differs from the hole \heh2, whose filling may cause different instances to evaluate to different values due to non-capture-avoiding substitution. For example, filling hole \heh2 with the expression $x+2$ will cause the instances to resolve to $5$ and $6$, respectively.

\begin{listing}
  \inputhminted{instance_illustration}
  \caption{Illustration of hole instances}
  \label{fig:instance-illustration}
\end{listing}

The current implementation assigns an identifier $i$ to each instance of a hole, and the instance number is unique between all instances of a hole. While this makes perfect sense for \heh2, the assignment of two separate holes to \heh1 may confuse Hazel users, since these hole instances are identical and filling them with any value will result in the same value. The solution is to unify all instances of a hole which share the same (physically equal) environment, and thus identify hole instances by hole number and environment. A set of hole instances that share the same environment will be called a \textbf{unique hole closure}, or simply \textbf{hole closure}\footnote{``Hole closure'' also is used to describe the generalized closure around hole expressions as described in \Cref{sec:env_model_evaluation}. Here we are referring to the set of instances of the same hole that share the same physical environment. Hence we call this interpretation ``unique hole closure'' to distinguish it from the former interpretation, but the interpretation should be clear from context.}.

To illustrate why physical equality is used to identify environments, consider the case shown in \Cref{fig:physical-equality-illustration}. This simpler program evaluates to \[
  [x\leftarrow 2]\hehole^1 + [x\leftarrow 2]\hehole^1
\] In this case, hole 1 has two instances with two environments with structurally equal bindings. If the argument to the second invocation of $f$ is changed to $3$, then the holes will have different environments and may thus fill to different values. This may be confusing to the Hazel user; what appears to be a single hole closure is actually two different hole closures which incidentally have the same values bound to its variables.

An intuitive way of understanding the use of physical equality is that separate \textit{instantiations} of the same hole should be distinguished. This is highly related to function applications. A hole may only appear multiple times in the result in two different ways: it may exist in the body of a function that is multiple times (multiple hole instantiations), or it may appear in a hole that is referenced from other holes (shared hole instantiation).

\begin{listing}
  \inputhminted{physical_equality_illustration}
  \caption{Illustration of physical equality for environment memoization}
  \label{fig:physical-equality-illustration}
\end{listing}

\section{The existing hole instance numbering algorithm}
\label{sec:existing-hole-numbering}

Hole numbering is a process that follows evaluation and operates on the evaluation result\footnote{The function in the existing codebase that performs hole renumbering is \mintinline{ocaml}|Program.renumber|. We may refer to it throughout this text as ``hole numbering,'' ``hole renumbering,'' or ``hole tracking.''}. It assigns a hole instance number to each hole. The hole numbering algorithm is not discussed in the Hazelnut Live description. We also will not describe it as a set of judgments, for brevity. It is a breadth-first search of the result, recursing through holes. When a hole is encountered, it is assigned a unique hole instance number and added to a data structure \mintinline{ocaml}|HoleInstanceInfo.t| that keeps track of all hole instances. Each hole instance's hole number, hole instance number, hole closure environment, and path\footnote{The path of a hole is the recursive list of hole parents that must be traversed in order to reach a hole. In other words, this is the path to a hole if we envision the result expression as a tree, in which each hole is a node that fathers all of its variable binding expressions.} is stored in this data structure. The \mintinline{ocaml}|HoleInstanceInfo.t| is in turn stored in the \mintinline{ocaml}|Result.t| that stores all of the information about an evaluated program. The primary use of \mintinline{ocaml}|HoleInstanceInfo.t| is for the context inspector. With this data structure, users may easily iterate all instances of a selected hole, examine the hole path of a selected hole, examine the environment of a selected hole, or navigate to another hole instance.

% \begin{singlespace}
%   % see: https://tex.stackexchange.com/a/110156
%   \begin{figure}
%     \centering
%     \begin{subfigure}{\textwidth}
%       \begin{mdframed}[bottomline=false]
%         \input{renumber_old_bigstep}
%       \end{mdframed}
%     \end{subfigure}
%   \end{figure}
%   \begin{figure}
%     \ContinuedFloat
%     \begin{subfigure}{\textwidth}
%       \begin{mdframed}[topline=false]
%         \input{renumber_old_bigstep2}
%       \end{mdframed}
%     \end{subfigure}
%     \caption{Big-step semantics for the previous hole instance numbering algorithm}
%     \label{fig:big-step-renumber-old-rules}
%   \end{figure}
% \end{singlespace}

\section{Issues with the current implementation}
\label{sec:current-problems}

Consider the program shown in \Cref{fig:hole_renumbering_problem}. A performance issue appears with the existing evaluator with the program shown in \Cref{fig:hole_renumbering_problem}\footnote{This was first brought to attention by a GitHub issue at \url{https://github.com/hazelgrove/hazel/issues/536}.}. As we increase the number of consecutive \mintinline{ocaml}|let| expressions, we get an exponential slowdown that makes evaluation impractical for $n>10$. The results of running this program for several values of $n$ is shown in tabular form in \Cref{tab:perf-hole-blowup} and graphically at \Cref{fig:perf-renum-dev}.

For now, let us consider the case when $n=3$. When evaluating with environments\footnote{When evaluating using the substitution model, evaluation also slows down exponentially, because the variables are eagerly substituted into the hole environments. We do not have a performance issue with evaluation with environments because of lazy variable lookups.}, the result is shown in \Cref{fig:hole-renumbering-solution-structure}.

The program slowdown happens in the hole numbering process. Recall from \Cref{sec:existing-hole-numbering} that the hole numbering process is a simple tree traversal algorithm. Thus, each time a hole (with the same environment) is encountered, it and all of its descendant holes will be given more hole instance numbers. This leads to the hole numbering shown in \Cref{fig:hole-renumbered-result}. We see that there are four instances of hole 1, two instances of hole 2, and one instance of hole 3. In sum, we see that there are eight total hole instances. It should be intuitive that the number of holes increases by powers of two; the total number of holes (including the instance of hole 4 in this case) will be $2^N$.

Clearly this is undesirable from an efficiency perspective. It is also undesirable from the perspective that there is only one instantiation of each of the holes. While there are multiple paths to each node, we would like to change the representation to match that of the unique hole closures or hole instantiations as described in \Cref{sec:instance-illustration}.

\begin{listing}
  \centering
  \inputhminted{holes_consecutive}
  \caption{A Hazel program that generates an exponential ($2^N$) number of total hole instances}
  \label{fig:hole_renumbering_problem}
\end{listing}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \node[] (hole4) {$[\env^4]\hehole^4$};
    \node[below=of hole4] (hole3) {$[\env^3]\hehole^3$};
    \node[below=of hole3] (hole2) {$[\env^2]\hehole^2$};
    \node[below=of hole2] (hole1) {$[\varnothing]\hehole^1$};

    \draw[->] (hole4) -- node [midway,left] {$c$} (hole3);
    \draw[->] (hole4) to[bend left=60] node [midway,right] {$b$} (hole2);
    \draw[->] (hole4) to[bend left=80] node [midway,right] {$a$} (hole1);
    \draw[->] (hole3) -- node [midway,left] {$b$} (hole2);
    \draw[->] (hole3) to[bend right=60] node [midway,left] {$a$} (hole1);
    \draw[->] (hole2) -- node [midway,left] {$a$} (hole1);
  \end{tikzpicture}
  \caption{Structure of the result of the program in \Cref{fig:hole_renumbering_problem}}
  \label{fig:hole-renumbering-solution-structure}
\end{figure}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \node[] (hole41) {$[\env^4]\hehole^{4:1}$};
    \node[below=of hole41] (hole31) {$[\env^3]\hehole^{3:1}$};
    \node[below=of hole31] (hole21) {$[\env^2]\hehole^{2:2}$};
    \node[below=of hole21] (hole11) {$[\varnothing]\hehole^{1:4}$};
    \node[left=of hole21] (hole12) {$[\varnothing]\hehole^{1:3}$};
    \node[left=of hole12] (hole13) {$[\varnothing]\hehole^{1:2}$};
    \node[above=of hole13] (hole22) {$[\env^2]\hehole^{2:1}$};
    \node[left=of hole22] (hole14) {$[\varnothing]\hehole^{1:1}$};

    \draw[->] (hole41) to[] node[left] {$c$} (hole31);
    \draw[->] (hole41) to[] node[below right] {$b$} (hole22);
    \draw[->] (hole41) to[] node[above left] {$a$} (hole14);
    \draw[->] (hole31) to[] node[left] {$b$} (hole21);
    \draw[->] (hole31) to[] node[above left] {$a$} (hole12);
    \draw[->] (hole22) to[] node[above left] {$a$} (hole13);
    \draw[->] (hole21) to[] node[above left] {$a$} (hole11);
  \end{tikzpicture}
  \caption{Numbered hole instances in the result of \Cref{fig:hole_renumbering_problem}}
  \label{fig:hole-renumbered-result}
\end{figure}

\subsection{Hole instance path versus hole closure parents}
\label{sec:closure-parents}

Visually, we would like to change the hole tracking to use a representation more similar to \Cref{fig:hole-renumbering-solution-structure} rather than that of \Cref{fig:hole-renumbered-result}. In the old representation, each hole instance is uniquely identified by a hole number and hole path.

In the new representation, hole instantiations are uniquely identified by hole number and environment, and are not uniquely identified by a path anymore. Thus, for each hole closure we instead keep track of a list of its parent holes.

We note that these two representations of a graph are equivalent\footnote{This structure is more specifically a join-semilattice.}, assuming that nodes sharing an environment are considered to be physically equal. The first describes the path to each node, while the latter is a well-known adjacency list. Either representation of a graph can be used to construct the other, but the latter is much more efficient in the case of a dense graph.

Changing the structure from using hole paths to hole parents forces a minor change to the Hazel UI. When a user selects a hole, rather than showing the path to the hole, the list of parents to the hole are shown instead.

\section{Algorithmic concerns and a two-stage approach}
\label{sec:two-stage-renumber}

To efficiently build the new hole-tracking data structure, we expect to have a fast lookup of hole numbers and environment identifiers. On the other hand, we want the interface of this data structure to be similar to the interface of \mintinline{ocaml}|HoleInstanceInfo.t|: the user should be able to look up environments by hole number and hole closure number.

To efficiently handle both of these interfaces, we require two different data structures. The first is an auxiliary data structure \mintinline{ocaml}|HoleClosureInfo_.t| that is a map $\hci:(u,\sigma)\mapsto(i,\pth)$ (where $\pth$ indicates the list of hole closure parents). The second is the data structure that will be used for the context inspector and hole closure lookups, \mintinline{ocaml}|HoleClosureInfo.t|, that is a map $\hci:(u,i)\mapsto(\sigma,\pth)$. The maps are implemented as hashmaps for efficient lookups and updates\footnote{Note that this is one of the few places where a hashtable implementation is appropriate in the context of this project, since we do not copy these data structures. However, there will likely not be a major performance benefit; the main benefit lies in memoizing environments.}. The first stage of this algorithm is to build the \mintinline{ocaml}|HoleClosureInfo_.t|; the second stage is to convert it to a \mintinline{ocaml}|HoleClosureInfo.t|\footnote{It is a good time to bring up whether algorithmic efficiency is a matter of concern at all }.

For convenience, we do not use two different symbols for these two data structures; the difference is purely an implementation detail regarding the construction of the data structure. The conversion from \mintinline{ocaml}|HoleClosureInfo_.t| to \mintinline{ocaml}|HoleClosureInfo.t| is trivial and will not be described here in detail. It simply involves looping over the unique hole closures and changing the mapping to be indexed by hole number and hole closure number.

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{ppn_bigstep}
    \end{singlespace}
  \end{mdframed}
  \caption{Big-step semantics for hole closure numbering}
  \label{fig:big-step-renumber-new-rules}
\end{figure}

\subsection{Hole closure numbering order}
\label{sec:numbering-order}

The order of the numbers assigned to hole closures is not specified in the algorithm shown in \Cref{fig:big-step-renumber-new-rules}, but it is a consideration in the implementation. In the existing implementation, the evaluation result is traversed in a breadth-first search (BFS) order. On the other hand, our implementation is more simply implemented using a depth-first search (DFS) order. This changes the order that hole closures are encountered and numbered. While the hole closure number is not specified explicitly ordered value, certain orderings may be more intuitive to the user. A choice of explicit hole numbering order is left to future work.

\section{Unification with closure post-processing}
\label{sec:renumbering_memoization}

\subsection{Modifications to the instance numbering rules}
\label{sec:memoization-instance-numbering}

\subsection{Unification with closure post-processing}
\label{sec:unification-postprocessing}

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{pp_bigstep}
    \end{singlespace}
  \end{mdframed}
  \caption{Big-step semantics for post-processing}
  \label{fig:big-step-postprocessing-rules}
\end{figure}

\section{Fast structural equality checking}
\label{sec:fast-equals}

After the hole instance numbering is solved, there is an additional performance issue that is related to a recursive traversal of the evaluation result. After evaluation and hole numbering, there is an additional step (located in \mintinline{ocaml}{Model.update_program}) that compares two evaluation results (\mintinline{ocaml}|Result.t|) using a structural equality\footnote{Structural equality (\mintinline{ocaml}|==|) is implemented by recursively checking the value equality of two expressions, and can be thought of as a tree traversal.} check.

This step is also very slow, so we memoize it by environments. We implement a manual structural checking algorithm, \mintinline{ocaml}|DHExp.fast_equals|. For any leaf node (node with no subexpressions), the value of the node is compared for equality. For branch nodes (nodes with subexpressions), the nodes are equal if subexpressions are equal and if the node's properties are equal. Importantly, the equality check for environments is simply to check if the environment identifiers are equal.

A comparison of the performance before and after this change can be visualized in \Cref{tab:perf-hole-blowup}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
