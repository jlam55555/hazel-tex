\chapter{Discussion of theoretical results}
\label{sec:discussion}

\section{Metatheorems governing FAR}
\label{sec:far-meta}

\todo{filling (from original paper)}

\todo{commutativity}

\todo{all closures will be evaluated exactly once -- this allows holes that have not yet been evaluated in the result to be successfully re-evaluated (assuming program terminates) and maintains the invariant that all closures will be evaluated at the end of evaluation}

\section{FAR for notebook-style editing}
\label{sec:notebook-ui}

One of the primary qualities of computational notebooks is the ability to run sections of the code at a time, primarily for computational purposes. We may reproduce this behavior in a limited way.

We may model a notebook-style program as a linear sequence of sections or cells. Each cell, can be modeled as a set of variable bindings: the ``outputs'' of evaluating the section. We may interpret a \mintinline{ocaml}|let| statement in Hazel to be a single-output section.

Consider the sample notebook-style program shown in \Cref{fig:matlab-notebook-example}. Here, we have two sections, which compute three different variables. If we add a third section containing the statement \mintinline{matlab}|a = x + y;|, then we may obtain the value of $a$ by only executing the third section and not re-evaluating the first two sections, because the workspace is saved.

Now, consider the comparable program in \Cref{fig:hazel-notebook-example}. If the user types in the expression \hmintinline{x + y} or \hmintinline{let a = x + y in /\heh1/}, then a fill operation is detected, and the new expression is computed with the environment stored in hole 1's closure. In fact, if the user continues to make any changes below the fourth \mintinline{ocaml}|let| expression, they will all be considered to be valid fill operations against the edit state shown in \Cref{fig:hazel-notebook-example}, so the first four statements never have to be re-evaluated. As the user continues to edit downwards, new holes will be created and the newest edits may be considered fill operations from more recent edits.

Additionally, we have a reproducibility benefit here. In most notebook-style editors, such as MATLAB's live editor, running sections out of order may cause a different program output than if the program had been run in order. For example, if the user runs the section section twice after evaluating the first section \Cref{fig:matlab-notebook-example} is run twice in a row, then the output would be different than if the program was run from start to finish. On the other hand, the Hazel program in \Cref{fig:hazel-notebook-example} will always give the same result as if evaluation had begun from the top, as guaranteed by the commutativity property of FAR.

\begin{figure}
  \centering
  \inputminted{matlab}{lstings/matlab_notebook_example.m}
  \caption{Sample notebook-style program in MATLAB}
  \label{fig:matlab-notebook-example}
\end{figure}

\begin{figure}
  \centering
  \inputhminted{hazel_notebook_example}
  \caption{Sample notebook-style program in Hazel}
  \label{fig:hazel-notebook-example}
\end{figure}

The limitation of using Hazel as a computational notebook is that the fill-and-resume operation is limited to cases where there is a hole in a previous edit state as a parent of the root of the diff. If a user programs by always appending to or editing near the bottom of their program, FAR will be very beneficial because most edits will lead to valid fill operations. It may be difficult to quantify the real performance benefit due to large variations in programming styles. Different heuristics for choosing a past edit state to compare, as discussed in \Cref{sec:far-past-edit-states}, will also affect the performance of FAR.

\section{Generalized views on non-empty holes and FAR}
\label{sec:generalized-holes-far}

The work performed for FAR leads us to the following nice generalizations of some of the concepts we've encountered through this work.

\subsection{Generalized non-empty holes}
\label{sec:generalized-neholes}

Non-empty holes play a central hole in Hazel's ability to provide continuous feedback, as well as in the ability to resume computation in FAR. We may interpret an empty hole as encapsulating a well-formed expression in some incompatible outer expression.

It may be helpful to also imagine that the entire program lies in a non-empty hole. In this interpretation, regular program evaluation (from the start) may be considered a degenerate case of fill-and-resume, where the root of the diff is a non-fill diff that gets propagated up to this non-empty hole. This hole will also nicely serve as the parent for all holes in a non-complete program in the \mintinline{ocaml}|HoleClosureInfo.t|, although the parent of this hole would then not be well-defined.

\subsection{Generalized FAR}
\label{sec:generalized-far}

It is possible to express every evaluation operation as a FAR operation, assuming that we have the ability to look back an unlimited number of edit states. The intuition behind this is that the initial state of a program is the empty hole $\hehole^1$. It is trivial to prove that using the rules given by the fill diff that every edit state produces either a no diff or a fill diff judgment against this edit state.

For practical reasons, it may be less efficient to perform a fill diff against an arbitrary number of states, or even to store the entire history of a program. Also, the whole history of a program may not be available. In the case of a parsed program or an example program, which is specified as an edit state rather than a history of edit actions, we would need additional machinery to produce a possible series of edit actions that leads to this state from the empty state.

