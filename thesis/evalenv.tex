\section{Implementing the environment model of evaluation}
\label{sec:env_model_evaluation}

\subsection{Hazel-specific implementation}
\label{sec:eval_with_envs}

In the case of Hazel (which does not prioritize speed of evaluation in its implementation, and is not a compiled language), evaluation with (reified) environments offers an additional (performance) benefit over the substitution model: the ability to easily identify (and thus memoize) operations over environments. This is useful for the optimizations described later in this paper.

The implementation of evaluation in Hazel differs from a typical interpreter implementation of evaluation with environments in three regards: we need to account for hole environments; environments are uniquely identified by an identifier for memoization (in turn for optimization); and any closures in the evaluation result should be converted back into plain $\lambda$ abstractions.

\subsubsection{Evaluation rules}
\label{sec:evalenv-rules}

% TODO: walk through simple example

Omar et al. \cite{conf/popl/HazelnutLive19} describes evaluation with the substitution model using a little-step semantics with an evaluation context $\mathcal{E}$. 

The Hazel implementation follows a big-step model for evaluation, which is simpler, more performant, and does not require the evaluation context. Thus it is more convenient to follow a big-step semantics as shown in \Cref{fig:big-step-formal}. An equivalent small-step semantics is described in \Cref{sec:small-step-evalenv} but will not be discussed further.

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{evalenv_bigstep}
    \end{singlespace}
  \end{mdframed}
  \caption{Big-step semantics for the environment model of evaluation}
  \label{fig:big-step-formal}
\end{figure}

The evaluation model threads a run-time environment $\env$\footnote{The symbol $\env$ was chosen to represent the environment as it was used to represent hole environments in \cite{conf/popl/HazelnutLive19}. The relationship between these two environments will be discussed in \Cref{sec:holeenv_evalenv_connection}.} throughout the evaluation process. An environment is conceptually a mapping $\env:x\mapsto d$, although it will later be augmented to be more amenable to memoization.

Evaluation judgments are shown for a subset of the Hazel language, similar to the internal language described in \cite{conf/popl/HazelnutLive19}. The expressions considered include a single base type $b$, variables $x$, $\lambda$ abstractions, function application, and hole expressions. Casts and type ascriptions, which are part of the internal language follow the same rules as described in the Hazelnut paper, and thus are omitted here. Additionally, a rule is included for \mintinline{ocaml}|let| bindings, even if not strictly necessary. There are additional forms in the Hazel external and internal languages that are omitted for brevity and whose rules are trivial: these include binary sum injections and tuples, for which evaluation recurses through subexpressions. \mintinline{ocaml}|case| expressions are also omitted: it acts like a sequence of \mintinline{ocaml}|let| bindings. This select subset of the Hazel language will be reused throughout this paper for judgment rules; the goal is to provide a practical intuition of the evaluation semantics of Hazel that is close to the implementation, and not to provide a minimal theoretic foundation or the complete set of rules for all Hazel expressions. The latter is deferred to the source code in the reference implementation. Patterns and pattern holes will also be omitted from the rules, as they are not the focus of this work.

As always, elements of the base type are values and do not further evaluate. Bound variables evaluate to their value in the environment. (Unbound variables are marked as free during elaboration and do not further evaluate.)

$\lambda$-abstractions $\lambda x.d$ are no longer final values; they evaluate further to the function closure $[\env]\lambda x.d$, which captures the lexical environment of the $\lambda$ expression\footnote{This step is conceptually similar to the first step of closure conversion, in which $\lambda$-abstractions are converted to functions that take two parameters: the argument and the environment.}.

A description of recursive $\lambda$-abstractions (the fixpoint form) is described in \Cref{sec:rec_impl}.

Function application is broken into two cases: if the expression in function position evaluates to a closure and the argument matches the argument pattern, then the evaluated expression in argument position extends the closure's environment, and that extended environment is used as the lexical environment in which to evaluate the $\lambda$ expression body. Otherwise, the expression in function position must evaluate to an indeterminate (failed cast) form, in which case evaluation cannot proceed further. The case of failed pattern matches is described in \Cref{sec:failed_pattern_match}.

% TODO: lexical environment = current evaluation environment
% TODO: reference specific rules
% TODO: cite closure conversion
% TODO: move discussion of closure conversion to background section

\mintinline{ocaml}|let| bindings extend the current lexical environment with the bound variable. As with $\lambda$-abstractions, the case in which the pattern match fails is described in \Cref{sec:failed_pattern_match}.

\subsubsection{Evaluation of holes}
\label{sec:holeenv_evalenv_connection}

Hole expressions are separated into the empty and non-empty cases due to the lack of empty exprsessions, as in the original Hazelnut and Hazelnut Live descriptions. When evaluation reaches a hole, the hole environment is simply set to be equal to the lexical environment. In this interpretation, free variables do not exist in the hole environment.

Note that the initial hole environment is different than in the substitution model. When evaluating using the substitution model, the initial hole environment generated by elaboration is the identity substitution $\text{id}({\Gamma})$, and variable bindings are recursively substituted into the environment's bindings. This is not necessary anymore with the environment model, and the initial environment created by elaboration is not as important. In this interpretation, free variables exist in the hole environment as the identity substitution.

It is convenient to replace the identity substitution with a distinguished empty environment (represented by $\varnothing$) that indicates that evaluation has not yet reached a hole. This will also be useful for detecting errors with the evaluation boundary discussed in \Cref{sec:eval_boundary}.

\subsubsection{Evaluation of recursive functions}
\label{sec:rec_impl}

When evaluating with substitution, recursion needs to be explicitly handled using a fixpoint form that allows for self-recursion, otherwise inifinitely recursive substitution will occur.

Recursion with the environment model also requires self-reference, but this can be achieved in two ways: by accounting for the fixpoint form, or by using self-referential data structures. In OCaml, self-referential (mutually recursive) data can be achieved using the \mintinline{ocaml}|let rec| keyword or by using \mintinline{ocaml}|ref|s (mutable data cells); however, the latter will affect the purity of the implementation, as discussed in \Cref{sec:purity}.

Both pure methods were implemented; their tradeoffs are described below. The final implementation (and the rules shown in \Cref{fig:big-step-formal}) uses the implementation with the fixpoint form, although the choice is somewhat arbitrary.

Performing evaluation with the fixpoint form follows very similar rules to the substitution model. Recursive $\lambda$ functions in the external language elaborate to a $\lambda$ function wrapped in a \mintinline{ocaml}|FixF| variant during elaboration in the internal language\footnote{The current implementation only allows recursion for type-ascribed \mintinline{ocaml}|let| expressions with a single $\lambda$ abstraction on the RHS. Mutual recursion is currently not supported, but is being worked on in the \href{https://github.com/hazelgrove/hazel/tree/mutual-rec}{mutual-rec} branch. The described implementation should extend straightforwardly to an implementation of mutual recursion involving self-reference of a tuple and projection out of the tuple.}. The evaluation of the \mintinline{ocaml}|FixF| form introduces the self-reference to the current environment. To do this, the body expression is first evaluated without the self-reference; that evaluated expression is added to the environment; and then the body expression is evaluated again, with the self-reference\footnote{Evaluating the body expression twice may seem expensive, except that the body is (in the current implementation) always a lambda function, which trivially evaluates to a closure by binding its environment. As a result, we can simplify the evaluation of a \mintinline{ocaml}|FixF| to one of the following forms. The first occurs when the recursive function is defined, and the second occurs when the recursive form is looked up in its environment (and unwrapped).
  \begin{mathpar}
    \Infer{EvalB-FixF$_1$}{}{
      \env\vdash\fix f.\lambda x.d\Downarrow [\env,f\leftarrow \fix f.[\env]\lambda x.d]\lambda x.d
    }
    \and
    \Infer{EvalB-FixF$_2$}{}{
      \env\vdash\fix f.[\env']\lambda x.d\Downarrow [\env',f\leftarrow \fix f.[\env']\lambda x.d]\lambda x.d
    }
  \end{mathpar}
  Mutual recursion can be implemented as a self-reference applied to a tuple of $\lambda$ functions, which requires the more general form presented in \Cref{fig:big-step-formal}. It also does not take many evaluation steps and is thus not an expensive operation.}. The unwrapping of the recursive function occurs when the recursive form is looked up in its environment, which is indicated by the special variable evaluation rule EvalB-Unwind.

We may avoid the fixpoint form by using mutually-recursive data structures, so that a closure may contain an environment which contains itself as a binding. This is easy to implement in a language with pointers or mutable references, and how recursion is generally implemented. Mutually-recursive data in OCaml is somewhat tricky in the general case, as it requires statically-constructive forms\footnote{\href{https://ocaml.org/manual/letrecvalues.html}{\S10.1: Recursive definitions of values} of the OCaml reference describes this in greater detail. Simply put, this prevents recursive variables from being defined as arguments to functions, instead only allowing recursive forms to be arguments to data constructors.}. In the more general case of mutual recursion, this would likely make implementation very tricky, and it would be more practical to use impure \mintinline{ocaml}|ref|s to achieve self-reference. However, for the simple case of a simply recursive function, we may recognize \mintinline{ocaml}|let|-bindings which introduce a function, and statically construct the mutual recursion using the rule shown in \Cref{fig:rec-closures-let}. This is very similar to the way that \mintinline{ocaml}|FixF| expressions are inserted automatically during elaboration; the need for that elaboration step is eliminated, since the \mintinline{ocaml}|FixF| form doesn't exist during evaluation.

% REF: ^ this is how recursion is generally implemented

\begin{figure}
  \centering
  \begin{singlespace}
    \begin{mathpar}
      \Infer{EvalB-LetSimpleRec}{
        \env'=\env,f\leftarrow d_1' \\
        d_1'=[\env']\lambda x.d_1 \\
        \env'\vdash d_2\Downarrow d
      }{
        \env\vdash\texttt{let }f=\lambda x.d_1\texttt{ in }d_2\Downarrow d
      }
    \end{mathpar}
  \end{singlespace}
  \caption{Evaluation rule for simple recursion using self-recursive data structures}
  \label{fig:rec-closures-let}
\end{figure}

% TODO: notes on recursive form not being able to distinguish between self references and non-self-references, leading to slightly different results in the context inspector
Using the recursive environment in closures helps improve performance, due to the elimination of special processing (unwinding) for recursive function definitions and invocations. However, it complicates the display of recursive functions in the context inspector and structural equality checking, due to infinite recursion. The first problem is solved by re-introducing the \mintinline{ocaml}|FixF| form during postprocessing (\Cref{sec:closures_to_lambdas}) by detecting recursive environments and converting them to \mintinline{ocaml}|FixF| expressions; however, there is a nuance that may cause the postprocessed result to be slightly different\footnote{
  To illustrate this, consider the simple Hazel program:
  \inputhminted{missing_fixf}
  The result will be a closure of hole 1 with the identifiers \mintinline{ocaml}|x| and \mintinline{ocaml}|f| in scope. When evaluating using the \mintinline{ocaml}|FixF| form, the binding for \mintinline{ocaml}|f| will be the expression $(\fix f.[\varnothing]\lambda x.\hehole^1)$, and the binding for \mintinline{ocaml}|x| is $([f\leftarrow \fix f.[\varnothing]\lambda x.\hehole^1]\lambda x.\hehole^1)$. \mintinline{ocaml}|f| is bound to the closure in the EvalB-Fix rule, and \mintinline{ocaml}|x| is bound during EvalB-Ap to the evaluated value of \mintinline{ocaml}|f|.

  However, when evaluating with a recursive data structure, both \mintinline{ocaml}|x| and \mintinline{ocaml}|f| refer to the same value $d=([f\leftarrow d]\lambda x.\hehole^1)$. It is impossible to discern the two and decide where to begin the ``start of the recursion'', i.e., to determine that \mintinline{ocaml}|f| should be a \mintinline{ocaml}|FixF| expression and \mintinline{ocaml}|x| should be a \mintinline{ocaml}|Lam| expression, at least without significant additional extra effort. Thus to remove the recursion, we may arbitrarily decide that the outermost recursive form should be a \mintinline{ocaml}|Lam| expression and set the recursive binding in its environment to be a \mintinline{ocaml}|FixF| form, which will successfully remove the recursion but mistakenly change some expressions that would be \mintinline{ocaml}|FixF| forms to \mintinline{ocaml}|Lam| expressions. Whether this distinction is very important is another story, but it may at least confuse the user.
}. The second problem is solved by the fast equality checker for memoized environments described in \Cref{sec:fast-equals}, which is useful even for non-recursive environments. We may also say that using recursive data structures without mutable \mintinline{ocaml}|ref|s is limited by the language limitations, necessitating workarounds even for the simply-recursive case, and potentially much more complicated workarounds for the mutual recursion case.

The performance improvement is described in \Cref{sec:evaluation}. The complexities of postprocessing outweigh the small performance benefit, so it was chosen for the final implementation. However, both are viable for a practical implementation of recursion using only pure constructs in OCaml.

% sample figure
% \begin{figure}
%   \centering
%   \begin{tikzpicture}[
%     box/.style={rectangle,draw=green!60,fill=green!5,very thick,minimum size=7mm}
%     ]
%     \node[box] (ones) {ones};
%     \node[rectangle] (one) [right=of ones] {$1::$};
%     \draw[<-] (ones.east) -- (one.west);
%     \draw[->,dashed] (one.east) .. controls +(right:10mm) and +(down:20mm) .. (ones.south);
%   \end{tikzpicture}
%   \caption{Tying the knot}
%   \label{fig:tying-the-knot}
% \end{figure}

\subsubsection{Evaluation of failed pattern matching}
\label{sec:failed_pattern_match}

\subsection{The evaluation boundary, general closures, and post-processing}
\label{sec:closures_to_lambdas}


% TODO: describe why the result from substitution is better than the result from environments

% TODO: example programs:
% - lambda and fix forms
% - holes inside and outside boundary
% - recursion through hole environments

% two-stage approach

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{pplc_bigstep}
    \end{singlespace}
  \end{mdframed}
  \caption{Big-step semantics for $\lambda$-conversion post-processing}
  \label{fig:big-step-inside-formal}
\end{figure}

\subsection{A strict evaluation boundary}
\label{sec:eval_boundary}

% TODO: example program: pattern doesn't match

\subsubsection{Alternative evaluation strategies}
\label{sec:pattern_nomatch_strategies}

% two alternatives:
% - create new "pseudo-hole" form like FailedCast, but one which stores environment
% - speculatively evaluate, don't need to store environment and boundvar -> freevar if not bound (but bad for case)

\subsection{Post-processing memoization}
\label{sec:memoization}

\subsubsection{Modifications to the environment datatype}
\label{sec:memoization-evalenv}

\subsubsection{Modifications to the post-processing rules}
\label{sec:memoization-postprocessing}

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{pplc_memoization_bigstep}
    \end{singlespace}
  \end{mdframed}
  \caption{Big-step semantics modifications for environment memoization}
  \label{fig:big-step-memoization-rules}
\end{figure}

\subsection{Purity}
\label{sec:env-purity}

% threading around state: technically still pure, represented very similar to rules
% evalenv number generation is threaded around very similar to metavargen, but
% somewhat unwieldy and 

\subsubsection{Tradeoffs in elegance, complexity, runtime overhead}
\label{sec:elegance-and-complexity}

% purity is a technical term, elegance is not; unwieldiness
% is the additional complexity worth it?
% - nice benefits with memoization in specific cases (will see later)
% - general linear speedup even with the overhead and without benefits of memoization
% (e.g., see Fibonacci example)

\subsection{Implementation considerations}
\label{sec:evalenv_impl_considerations}

% considerations between different forms of the data structures
% e.g., evalenv storing results vs. storing plain dhexp, unwrapping vs. rejudging indet/boxedvalue

% TODO: discussion of data structures used in the implementation and theoretical bounds (appendix or not?)
% - e.g., lists vs. maps vs. hashtables (structural sharing)

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End: