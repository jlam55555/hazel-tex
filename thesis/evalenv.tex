\section{Implementing the environment model of evaluation}
\label{sec:env_model_evaluation}

\subsection{Hazel-specific implementation}
\label{sec:eval_with_envs}

In the case of Hazel (which does not prioritize speed of evaluation in its implementation, and is not a compiled language), evaluation with (reified) environments offers an additional (performance) benefit over the substitution model: the ability to easily identify (and thus memoize) operations over environments. This is useful for the optimizations described later in this paper.

The implementation of evaluation in Hazel differs from a typical interpreter implementation of evaluation with environments in three regards: we need to account for hole environments; environments are uniquely identified by an identifier for memoization (in turn for optimization); and any closures in the evaluation result should be converted back into plain $\lambda$ abstractions.

\subsubsection{Evaluation rules}
\label{sec:evalenv-rules}

% TODO: walk through simple example

Omar et al. \cite{conf/popl/HazelnutLive19} describes evaluation with the substitution model using a little-step semantics with an evaluation context $\mathcal{E}$. 

The Hazel implementation follows a big-step model for evaluation, which is simpler, more performant, and does not require the evaluation context. Thus it is more convenient to follow a big-step semantics as shown in \Cref{fig:big-step-formal}. An equivalent small-step semantics is described in \Cref{sec:small-step-evalenv} but will not be discussed further.

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{evalenv_bigstep}
    \end{singlespace}
  \end{mdframed}
  \caption{Big-step semantics for the environment model of evaluation}
  \label{fig:big-step-formal}
\end{figure}

The evaluation model threads a run-time environment $\env$\footnote{The symbol $\env$ was chosen to represent the environment as it was used to represent hole environments in \cite{conf/popl/HazelnutLive19}. The relationship between these two environments will be discussed in \Cref{sec:holeenv_evalenv_connection}.} throughout the evaluation process. An environment is conceptually a mapping $\env:x\mapsto d$, although it will later be augmented to be more amenable to memoization.

Evaluation judgments are shown for a subset of the Hazel language, similar to the internal language described in \cite{conf/popl/HazelnutLive19}. The expressions considered include a single base type $b$, variables $x$, $\lambda$ abstractions, function application, and hole expressions. Casts and type ascriptions, which are part of the internal language follow the same rules as described in the Hazelnut paper, and thus are omitted here. Additionally, a rule is included for \mintinline{ocaml}|let| bindings, even if not strictly necessary. There are additional forms in the Hazel external and internal languages that are omitted for brevity and whose rules are trivial: these include binary sum injections and tuples, for which evaluation recurses through subexpressions. \mintinline{ocaml}|case| expressions are also omitted: it acts like a sequence of \mintinline{ocaml}|let| bindings. This select subset of the Hazel language will be reused throughout this paper for judgment rules; the goal is to provide a practical intuition of the evaluation semantics of Hazel that is close to the implementation, and not to provide a minimal theoretic foundation or the complete set of rules for all Hazel expressions. The latter is deferred to the source code in the reference implementation.

As always, elements of the base type are values and do not further evaluate. Bound variables evaluate to their value in the environment. (Unbound variables are marked as free during elaboration and do not further evaluate.)

$\lambda$-abstractions $\lambda x.d$ are no longer final values; they evaluate further to the function closure $[\env]\lambda x.d$, which captures the lexical environment of the $\lambda$ expression\footnote{This step is conceptually similar to the first step of closure conversion, in which $\lambda$-abstractions are converted to functions that take two parameters: the argument and the environment.}.

A description of recursive $\lambda$-abstractions (the fixpoint form) is described in \Cref{sec:rec_impl}.

Function application is broken into two cases: if the expression in function position evaluates to a closure and the argument matches the argument pattern, then the evaluated expression in argument position extends the closure's environment, and that extended environment is used as the lexical environment in which to evaluate the $\lambda$ expression body. Otherwise, the expression in function position must evaluate to an indeterminate (failed cast) form, in which case evaluation cannot proceed further. The case of failed pattern matches is described in \Cref{sec:failed_pattern_match}.

% TODO: lexical environment = current evaluation environment
% TODO: reference specific rules
% TODO: cite closure conversion
% TODO: move discussion of closure conversion to background section

\mintinline{ocaml}|let| bindings extend the current lexical environment with the bound variable. As with $\lambda$-abstractions, the case in which the pattern match fails is described in \Cref{sec:failed_pattern_match}.

\subsubsection{Evaluation of holes}
\label{sec:holeenv_evalenv_connection}

Hole expressions are separated into the empty and non-empty cases due to the lack of empty exprsessions, as in the original Hazelnut and Hazelnut Live descriptions. When evaluation reaches a hole, the hole environment is simply set to be equal to the lexical environment. In this interpretation, free variables do not exist in the hole environment.

Note that the initial hole environment is different than in the substitution model. When evaluating using the substitution model, the initial hole environment generated by elaboration is the identity substitution $\text{id}({\Gamma})$, and variable bindings are recursively substituted into the environment's bindings. This is not necessary anymore with the environment model, and the initial environment created by elaboration is not as important. In this interpretation, free variables exist in the hole environment as the identity substitution.

It is convenient to replace the identity substitution with a distinguished empty environment (represented by $\varnothing$) that indicates that evaluation has not yet reached a hole. This will also be useful for detecting errors with the evaluation boundary discussed in \Cref{sec:eval_boundary}.

\subsubsection{Evaluation of recursive functions}
\label{sec:rec_impl}

When evaluating with substitution, recursion needs to be explicitly handled using a fixpoint form that allows for self-recursion, otherwise inifinitely recursive substitution will occur.

Recursion with the environment model also requires self-reference, but this can be achieved in two ways: by accounting for the fixpoint form, or by using self-referential data structures. In OCaml, self-referential (mutually recursive) data can be achieved using the \mintinline{ocaml}|let rec| keyword or by using \mintinline{ocaml}|ref|s (mutable data cells); however, the latter will affect the purity of the implementation, as discussed in \Cref{sec:purity}.

% TODO: experiment with tying the knot

% TODO: notes on current implementation only applying to annotated lambdas

% sample figure
% \begin{figure}
%   \centering
%   \begin{tikzpicture}[
%     box/.style={rectangle,draw=green!60,fill=green!5,very thick,minimum size=7mm}
%     ]
%     \node[box] (ones) {ones};
%     \node[rectangle] (one) [right=of ones] {$1::$};
%     \draw[<-] (ones.east) -- (one.west);
%     \draw[->,dashed] (one.east) .. controls +(right:10mm) and +(down:20mm) .. (ones.south);
%   \end{tikzpicture}
%   \caption{Tying the knot}
%   \label{fig:tying-the-knot}
% \end{figure}

\subsubsection{Evaluation of failed pattern matching}
\label{sec:failed_pattern_match}

\subsection{The evaluation boundary and post-processing}
\label{sec:closures_to_lambdas}


% TODO: describe why the result from substitution is better than the result from environments

% TODO: example programs:
% - lambda and fix forms
% - holes inside and outside boundary
% - recursion through hole environments

% two-stage approach

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{pplc_bigstep}
    \end{singlespace}
  \end{mdframed}
  \caption{Big-step semantics for $\lambda$-conversion post-processing}
  \label{fig:big-step-inside-formal}
\end{figure}

\subsection{A strict evaluation boundary}
\label{sec:eval_boundary}

% TODO: example program: pattern doesn't match

\subsubsection{Alternative evaluation strategies}
\label{sec:pattern_nomatch_strategies}

% two alternatives:
% - create new "pseudo-hole" form like FailedCast, but one which stores environment
% - speculatively evaluate, don't need to store environment and boundvar -> freevar if not bound (but bad for case)

\subsection{Post-processing memoization}
\label{sec:memoization}

\subsubsection{Modifications to the environment datatype}
\label{sec:memoization-evalenv}

\subsubsection{Modifications to the post-processing rules}
\label{sec:memoization-postprocessing}

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{pplc_memoization_bigstep}
    \end{singlespace}
  \end{mdframed}
  \caption{Big-step semantics modifications for environment memoization}
  \label{fig:big-step-memoization-rules}
\end{figure}

\subsection{Purity}
\label{sec:env-purity}

% threading around state: technically still pure, represented very similar to rules
% evalenv number generation is threaded around very similar to metavargen, but
% somewhat unwieldy and 

\subsubsection{Tradeoffs in elegance, complexity, runtime overhead}
\label{sec:elegance-and-complexity}

% purity is a technical term, elegance is not; unwieldiness
% is the additional complexity worth it?
% - nice benefits with memoization in specific cases (will see later)
% - general linear speedup even with the overhead and without benefits of memoization
% (e.g., see Fibonacci example)

\subsection{Implementation considerations}
\label{sec:evalenv_impl_considerations}

% considerations between different forms of the data structures
% e.g., evalenv storing results vs. storing plain dhexp, unwrapping vs. rejudging indet/boxedvalue

% TODO: discussion of data structures used in the implementation and theoretical bounds (appendix or not?)
% - e.g., lists vs. maps vs. hashtables (structural sharing)

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End: