\section{Implementing the environment model of evaluation}
\label{sec:env_model_evaluation}

\subsection{Hazel-specific implementation}
\label{sec:eval_with_envs}

In the case of Hazel (which does not prioritize speed of evaluation in its implementation, and is not a compiled language), evaluation with (reified) environments offers an additional (performance) benefit over the substitution model: the ability to easily identify (and thus memoize) operations over environments. This is useful for the optimizations described later in this paper.

The implementation of evaluation in Hazel differs from a typical interpreter implementation of evaluation with environments in three regards: we need to account for hole environments; environments are uniquely identified by an identifier for memoization (in turn for optimization); and any closures in the evaluation result should be converted back into plain $\lambda$ abstractions.

\subsubsection{Evaluation rules}
\label{sec:evalenv-rules}

% TODO: walk through simple example

Omar et al. \cite{conf/popl/HazelnutLive19} describes evaluation with the substitution model using a little-step semantics with an evaluation context $\mathcal{E}$. 

The Hazel implementation follows a big-step model for evaluation, which is simpler, more performant, and does not require the evaluation context. Thus it is more convenient to follow a big-step semantics as shown in \Cref{fig:big-step-formal}. An equivalent small-step semantics is described in \Cref{sec:small-step-evalenv} but will not be discussed further.

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{evalenv_bigstep}
    \end{singlespace}
  \end{mdframed}
  \caption{Big-step semantics for the environment model of evaluation}
  \label{fig:big-step-formal}
\end{figure}

The evaluation model threads a run-time environment $\env$\footnote{The symbol $\env$ was chosen to represent the environment as it was used to represent hole environments in \cite{conf/popl/HazelnutLive19}. The relationship between these two environments will be discussed in \Cref{sec:holeenv_evalenv_connection}.} throughout the evaluation process. An environment is conceptually a mapping $\env:x\mapsto d$, although it will later be augmented to be more amenable to memoization.

Evaluation judgments are shown for a subset of the Hazel language, similar to the internal language described in \cite{conf/popl/HazelnutLive19}. The expressions considered include a single base type $b$, variables $x$, $\lambda$ abstractions, function application, and hole expressions. Casts and type ascriptions, which are part of the internal language follow the same rules as described in the Hazelnut paper, and thus are omitted here. Additionally, a rule is included for \mintinline{ocaml}|let| bindings, even if not strictly necessary. There are additional forms in the Hazel external and internal languages that are omitted for brevity and whose rules are trivial: these include binary sum injections and tuples, for which evaluation recurses through subexpressions. \mintinline{ocaml}|case| expressions are also omitted: it acts like a sequence of \mintinline{ocaml}|let| bindings. This select subset of the Hazel language will be reused throughout this paper for judgment rules; the goal is to provide a practical intuition of the evaluation semantics of Hazel that is close to the implementation, and not to provide a minimal theoretic foundation or the complete set of rules for all Hazel expressions. The latter is deferred to the source code in the reference implementation. Patterns and pattern holes will also be omitted from the rules, as they are not the focus of this work.

As always, elements of the base type are values and do not further evaluate. Bound variables evaluate to their value in the environment. (Unbound variables are marked as free during elaboration and do not further evaluate.)

$\lambda$-abstractions $\lambda x.d$ are no longer final values; they evaluate further to the function closure $[\env]\lambda x.d$, which captures the lexical environment of the $\lambda$ expression\footnote{This step is conceptually similar to the first step of closure conversion, in which $\lambda$-abstractions are converted to functions that take two parameters: the argument and the environment.}.

A description of recursive $\lambda$-abstractions (the fixpoint form) is described in \Cref{sec:rec_impl}.

Function application is broken into two cases: if the expression in function position evaluates to a closure and the argument matches the argument pattern, then the evaluated expression in argument position extends the closure's environment, and that extended environment is used as the lexical environment in which to evaluate the $\lambda$ expression body. Otherwise, the expression in function position must evaluate to an indeterminate (failed cast) form, in which case evaluation cannot proceed further. The case of failed pattern matches is described in \Cref{sec:failed_pattern_match}.

% TODO: lexical environment = current evaluation environment
% TODO: reference specific rules
% TODO: cite closure conversion
% TODO: move discussion of closure conversion to background section

\mintinline{ocaml}|let| bindings extend the current lexical environment with the bound variable. As with $\lambda$-abstractions, the case in which the pattern match fails is described in \Cref{sec:failed_pattern_match}.

\subsubsection{Evaluation of holes}
\label{sec:holeenv_evalenv_connection}

Hole expressions are separated into the empty and non-empty cases due to the lack of empty exprsessions, as in the original Hazelnut and Hazelnut Live descriptions. When evaluation reaches a hole, the hole environment is simply set to be equal to the lexical environment. In this interpretation, free variables do not exist in the hole environment.

Note that the initial hole environment is different than in the substitution model. When evaluating using the substitution model, the initial hole environment generated by elaboration is the identity substitution $\text{id}({\Gamma})$, and variable bindings are recursively substituted into the environment's bindings. This is not necessary anymore with the environment model, and the initial environment created by elaboration is not as important. In this interpretation, free variables exist in the hole environment as the identity substitution.

It is convenient to replace the identity substitution with a distinguished empty environment (represented by $\varnothing$) that indicates that evaluation has not yet reached a hole. This will also be useful for detecting errors with the evaluation boundary discussed in \Cref{sec:eval_boundary}.

\subsubsection{Evaluation of recursive functions}
\label{sec:rec_impl}

When evaluating with substitution, recursion needs to be explicitly handled using a fixpoint form that allows for self-recursion, otherwise inifinitely recursive substitution will occur.

Recursion with the environment model also requires self-reference, but this can be achieved in two ways: by accounting for the fixpoint form, or by using self-referential data structures. In OCaml, self-referential (mutually recursive) data can be achieved using the \mintinline{ocaml}|let rec| keyword or by using \mintinline{ocaml}|ref|s (mutable data cells); however, the latter will affect the purity of the implementation, as discussed in \Cref{sec:purity}.

Both pure methods were implemented; their tradeoffs are described below. The final implementation (and the rules shown in \Cref{fig:big-step-formal}) uses the implementation with the fixpoint form, although the choice is somewhat arbitrary.

Performing evaluation with the fixpoint form follows very similar rules to the substitution model. Recursive $\lambda$ functions in the external language elaborate to a $\lambda$ function wrapped in a \mintinline{ocaml}|FixF| variant during elaboration in the internal language\footnote{The current implementation only allows recursion for type-ascribed \mintinline{ocaml}|let| expressions with a single $\lambda$ abstraction on the RHS. Mutual recursion is currently not supported, but is being worked on in the \href{https://github.com/hazelgrove/hazel/tree/mutual-rec}{mutual-rec} branch. The described implementation should extend straightforwardly to an implementation of mutual recursion involving self-reference of a tuple and projection out of the tuple.}. The evaluation of the \mintinline{ocaml}|FixF| form introduces the self-reference to the current environment. To do this, the body expression is first evaluated without the self-reference; that evaluated expression is added to the environment; and then the body expression is evaluated again, with the self-reference\footnote{Evaluating the body expression twice may seem expensive, except that the body is (in the current implementation) always a lambda function, which trivially evaluates to a closure by binding its environment. As a result, we can simplify the evaluation of a \mintinline{ocaml}|FixF| to one of the following forms. The first occurs when the recursive function is defined, and the second occurs when the recursive form is looked up in its environment (and unwrapped).
  \begin{mathpar}
    \Infer{EvalB-FixF$_1$}{}{
      \env\vdash\fix f.\lambda x.d\Downarrow [\env,f\leftarrow \fix f.[\env]\lambda x.d]\lambda x.d
    }
    \and
    \Infer{EvalB-FixF$_2$}{}{
      \env\vdash\fix f.[\env']\lambda x.d\Downarrow [\env',f\leftarrow \fix f.[\env']\lambda x.d]\lambda x.d
    }
  \end{mathpar}
  Mutual recursion can be implemented as a self-reference applied to a tuple of $\lambda$ functions, which requires the more general form presented in \Cref{fig:big-step-formal}. It also does not take many evaluation steps and is thus not an expensive operation.}. The unwrapping of the recursive function occurs when the recursive form is looked up in its environment, which is indicated by the special variable evaluation rule EvalB-Unwind.

We may avoid the fixpoint form by using mutually-recursive data structures, so that a closure may contain an environment which contains itself as a binding. This is easy to implement in a language with pointers or mutable references, and how recursion is generally implemented. Mutually-recursive data in OCaml is somewhat tricky in the general case, as it requires statically-constructive forms\footnote{\href{https://ocaml.org/manual/letrecvalues.html}{\S10.1: Recursive definitions of values} of the OCaml reference describes this in greater detail. Simply put, this prevents recursive variables from being defined as arguments to functions, instead only allowing recursive forms to be arguments to data constructors.}. In the more general case of mutual recursion, this would likely make implementation very tricky, and it would be more practical to use impure \mintinline{ocaml}|ref|s to achieve self-reference. However, for the simple case of a simply recursive function, we may recognize \mintinline{ocaml}|let|-bindings which introduce a function, and statically construct the mutual recursion using the rule shown in \Cref{fig:rec-closures-let}. This is very similar to the way that \mintinline{ocaml}|FixF| expressions are inserted automatically during elaboration; the need for that elaboration step is eliminated, since the \mintinline{ocaml}|FixF| form doesn't exist during evaluation.

% REF: ^ this is how recursion is generally implemented

\begin{figure}
  \centering
  \begin{singlespace}
    \begin{mathpar}
      \Infer{EvalB-LetSimpleRec}{
        \env'=\env,f\leftarrow d_1' \\
        d_1'=[\env']\lambda x.d_1 \\
        \env'\vdash d_2\Downarrow d
      }{
        \env\vdash\texttt{let }f=\lambda x.d_1\texttt{ in }d_2\Downarrow d
      }
    \end{mathpar}
  \end{singlespace}
  \caption{Evaluation rule for simple recursion using self-recursive data structures}
  \label{fig:rec-closures-let}
\end{figure}

% TODO: notes on recursive form not being able to distinguish between self references and non-self-references, leading to slightly different results in the context inspector
Using the recursive environment in closures helps improve performance, due to the elimination of special processing (unwinding) for recursive function definitions and invocations. However, it complicates the display of recursive functions in the context inspector and structural equality checking, due to infinite recursion. The first problem is solved by re-introducing the \mintinline{ocaml}|FixF| form during postprocessing (\Cref{sec:closures_to_lambdas}) by detecting recursive environments and converting them to \mintinline{ocaml}|FixF| expressions; however, there is a nuance that may cause the postprocessed result to be slightly different\footnote{
  To illustrate this, consider the simple Hazel program:
  \inputhminted{missing_fixf}
  The result will be a closure of hole 1 with the identifiers \mintinline{ocaml}|x| and \mintinline{ocaml}|f| in scope. When evaluating using the \mintinline{ocaml}|FixF| form, the binding for \mintinline{ocaml}|f| will be the expression $(\fix f.[\varnothing]\lambda x.\hehole^1)$, and the binding for \mintinline{ocaml}|x| is $([f\leftarrow \fix f.[\varnothing]\lambda x.\hehole^1]\lambda x.\hehole^1)$. \mintinline{ocaml}|f| is bound to the closure in the EvalB-Fix rule, and \mintinline{ocaml}|x| is bound during EvalB-Ap to the evaluated value of \mintinline{ocaml}|f|.

  However, when evaluating with a recursive data structure, both \mintinline{ocaml}|x| and \mintinline{ocaml}|f| refer to the same value $d=([f\leftarrow d]\lambda x.\hehole^1)$. It is impossible to discern the two and decide where to begin the ``start of the recursion'', i.e., to determine that \mintinline{ocaml}|f| should be a \mintinline{ocaml}|FixF| expression and \mintinline{ocaml}|x| should be a \mintinline{ocaml}|Lam| expression, at least without significant additional extra effort. Thus to remove the recursion, we may arbitrarily decide that the outermost recursive form should be a \mintinline{ocaml}|Lam| expression and set the recursive binding in its environment to be a \mintinline{ocaml}|FixF| form, which will successfully remove the recursion but mistakenly change some expressions that would be \mintinline{ocaml}|FixF| forms to \mintinline{ocaml}|Lam| expressions. Whether this distinction is very important is another story, but it may at least confuse the user.
}. The second problem is solved by the fast equality checker for memoized environments described in \Cref{sec:fast-equals}, which is useful even for non-recursive environments. We may also say that using recursive data structures without mutable \mintinline{ocaml}|ref|s is limited by the language limitations, necessitating workarounds even for the simply-recursive case, and potentially much more complicated workarounds for the mutual recursion case.

The performance improvement is described in \Cref{sec:evaluation}. The complexities of postprocessing outweigh the small performance benefit, so it was chosen for the final implementation. However, both are viable for a practical implementation of recursion using only pure constructs in OCaml.

% sample figure
% \begin{figure}
%   \centering
%   \begin{tikzpicture}[
%     box/.style={rectangle,draw=green!60,fill=green!5,very thick,minimum size=7mm}
%     ]
%     \node[box] (ones) {ones};
%     \node[rectangle] (one) [right=of ones] {$1::$};
%     \draw[<-] (ones.east) -- (one.west);
%     \draw[->,dashed] (one.east) .. controls +(right:10mm) and +(down:20mm) .. (ones.south);
%   \end{tikzpicture}
%   \caption{Tying the knot}
%   \label{fig:tying-the-knot}
% \end{figure}

\subsection{The evaluation boundary and general closures}
\label{sec:closures_to_lambdas}

Evaluation with the environment model is ``lazy'' in that evaluation steps that require the environment (e.g., evaluation of holes, and evaluation of variables) are only performed when evaluation reaches the expression of interest. Evaluation with the substitution model is ``eager'' because variable variable values propagate through all subexpressions (even unevaluated ones) upon binding. While lazy evaluation is better for performance, in the Hazel environment we expect to see fully-substituted values in the context inspector for hole contexts environments. This means that we require a postprocessing step to perform substitution of bound variables in environments to achieve the same result as if we had evaluated by means of substitution.

In other words, any unevaluated expression must be ``caught up'' to the substituted equivalent after evaluation. This requires that the environment be stored alongside the unevaluated expression, and that a postprocessing step should be taken to perform the substitution and discard the stored environment. Note that this is essentially performing substitution pass after evaluation, but is preferred over substitution during evaluation because it is only performed on the result (rather than all the intermediate expressions during evaluation).

We define the \textbf{evaluation boundary} to be the conceptual distinction between expressions for which evaluation has reached (``inside'' the boundary), and for those that remain unevaluated (``outside'' the boundary). This definition will be useful for describing the postprocessing algorithm.

\subsubsection{Evaluation of failed pattern matching using generalized closures}
\label{sec:failed_pattern_match}

There are two cases where an expression in the evaluation result may lie outside the evaluation boundary. The first is in the body of a $\lambda$ expression. A $\lambda$ expression evaluates to a closure, and thus captures an environment with it. The second case is that of an unmatched \mintinline{ocaml}|let| or \mintinline{ocaml}|case| expression (in which the scrutinee matches none of the rules), for which the body expression(s) will remain unevaluated in the result without an associated environment\footnote{There is a third place where pattern-matching may fail: the pattern of an applied $\lambda$ abstraction may not match its argument. However, this is not an issue since there exists a function closure containing the unevaluated expression's environment.}. This is not captured in the original description of Hazelnut Live \cite{conf/popl/HazelnutLive19} or in this paper because pattern-matching is not a primary concern of either of these works. However, it is a practical concern that arises from the introduction of evaluation with environments.

We solve this by introducing (lexical) \textbf{generalized closures}, the product of an arbitrary expression and its lexical environment. Traditionally, the term ``closure'' refers to \textbf{function closures}, which are the product of a $\lambda$ abstraction with its lexical environment. Hazelnut Live \cite{conf/popl/HazelnutLive19} introduces \textbf{hole closures}, which are the product of empty and non-empty holes with their lexical environments, and are fundamental to the Hazel live environment: they allow a user to inspect a hole's environment in the context inspector, and enable the fill-and-resume optimization. We propose generalizing the term ``closures'' to the definition stated above. Conceptually, all generalized closures represent a partial or stopped evaluation (using the environment model), as well as the state (the environment) that may be used to resume the evaluation.

The application of generalized closures to the problem of unevaluated \mintinline{ocaml}|let| or \mintinline{ocaml}|case| bodies is straightforward: if there is a failed pattern match, wrap the entire expression in a (generalized) closure with the current lexical environment. Then, the postprocessing can successfully perform the substitution.

\subsubsection{Generalization of existing hole types}
\label{sec:generalized-closures-datatypes}

\begin{figure}
  \centering
  \begin{singlespace}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputominted{ungeneralized_closures}
        \caption{Non-generalized closures}
        \label[figure]{fig:ungeneralized-datatypes}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputominted{generalized_closures}
        \caption{Generalized closures}
        \label[figure]{fig:generalized-datatypes}
      \end{subfigure}
    }
  \end{singlespace}
  \caption{Comparison of internal expression datatype definitions (in module \mintinline{ocaml}|DHExp|) for non-generalized and generalized closures.}
  \label{fig:generalized-closures-datatypes}
\end{figure}

Consider the abbreviated definition of the internal expression variant type in \Cref{fig:generalized-closures-datatypes}. In \Cref{fig:ungeneralized-datatypes} the previous implementation is shown (when evaluating using the substitution model), augmented with a type for function closures. There are ordinary \mintinline{ocaml}|Let| and \mintinline{ocaml}|Case| variants, which do not contain an environment. In this version, each expression variant that requires an environment has the environment hardcoded into the variant. In \Cref{fig:generalized-datatypes} the proposed version with generalized closures is shown. The \mintinline{ocaml}|Lam|, \mintinline{ocaml}|Let|, and \mintinline{ocaml}|Case| variants are unchanged. Importantly, the environments are removed from the hole types and a new generalized \mintinline{ocaml}|Closure| is introduced. In this model, a hole, $\lambda$ abstraction, unmatched \mintinline{ocaml}|let|, or unmatched \mintinline{ocaml}|case| expression is wrapped in the \mintinline{ocaml}|Closure| variant when evaluated.

The notation used to express a function closure may be extended to all generalized closure types. In particular, the environment for a hole changes from the initial notation used in \cite{conf/popl/HazelnutLive19}:
\begin{align}
  \label{eq:generalized-closure-notation}
  &[\env]\lambda x.d\tag{function closure} \\
  &[\env]\hhole{d}^u\tag{hole closure} \\
  &[\env](\texttt{let }x=d_1\texttt{ in }d_2)\tag{closure around \texttt{let}} \\
  &[\env](\texttt{case }x\texttt{ of }\text{rules})\tag{closure around \texttt{case}}
\end{align}

This implementation of closures is an improvement in two ways. Firstly, it simplifies the variant types by factoring out the environment, separating the ``core'' expression from the environment coupled with it. Secondly, it allows for a more intuitive understanding of holes in the environment model of evaluation. This solves the question of what environment to initialize a hole with when it is created during the elaboration phase: a hole is simply initialized without a hole environment, much as a function closure is initially without an environment (a plain syntactical $\lambda$ abstraction).

Note that while the generalized closures for the body expressions of $\lambda$ abstractions, unmatched \mintinline{ocaml}|let| expressions, and unmatched \mintinline{ocaml}|case| expressions represent expressions outside of the evaluation boundary, the expressions within non-empty holes (which also are bound to a hole closure) lie within the evaluation boundary. This shows the two goal that generalized closures achieve; to encapsulate a stopped expression (which is used during postprocessing to perform substitution), and to encapsulate an expression to be fill-and-resumed.

\subsubsection{Alternative strategies for evaluating past the evaluation boundary}
\label{sec:alt_strat_unevaluated}

Without generalized closures, unevaluated expressions (body expressions of $\lambda$ abstractions, unmatched \mintinline{ocaml}|let| expressions, and unmatched \mintinline{ocaml}|case| expressions) may be filled by a modified form of evaluation, which is only different in that a failed lookup (due to unmatched variables) will leave the variable unchanged\footnote{Ordinarily, a lookup on a \mintinline{ocaml}|BoundVar| (a variable which is in scope) should never fail during evaluation, and thus throws an exception during evaluation.}. However, this is essentially the same as substitution, and is expensive to do during evaluation. Also, while this speculative execution would be reasonable for \mintinline{ocaml}|let| expressions, it would be highly undesirable for \mintinline{ocaml}|case| expression, where it is easy to imagine an example where speculative execution leads to infinite recursion.

Another way to eliminate the case of unmatched expressions is to introduce an exhaustiveness checker to Hazel; then, we can guarantee (at run-time) that a pattern will never fail to match. This would also require changing the semantics of pattern holes, which always fail to match; the behavior may be changed so that pattern holes always match, but do not introduce new bindings. Since the focus of this work is not on patterns, these ideas were not explored and are left for future work in the Hazel project.

\subsection{The postprocessing substitution algorithm}
\label{sec:postprocessing-substitution}


% TODO: example programs:
% - lambda and fix forms
% - holes inside and outside boundary
% - recursion through hole environments

% two-stage approach

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{pplc_bigstep}
    \end{singlespace}
  \end{mdframed}
  \caption{Big-step semantics for $\lambda$-conversion post-processing}
  \label{fig:big-step-inside-formal}
\end{figure}

\subsection{Post-processing memoization}
\label{sec:memoization}

\subsubsection{Modifications to the environment datatype}
\label{sec:memoization-evalenv}

\subsubsection{Modifications to the post-processing rules}
\label{sec:memoization-postprocessing}

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{pplc_memoization_bigstep}
    \end{singlespace}
  \end{mdframed}
  \caption{Big-step semantics modifications for environment memoization}
  \label{fig:big-step-memoization-rules}
\end{figure}

\subsection{Purity}
\label{sec:env-purity}

% threading around state: technically still pure, represented very similar to rules
% evalenv number generation is threaded around very similar to metavargen, but
% somewhat unwieldy and 

\subsubsection{Tradeoffs in elegance, complexity, runtime overhead}
\label{sec:elegance-and-complexity}

% purity is a technical term, elegance is not; unwieldiness
% is the additional complexity worth it?
% - nice benefits with memoization in specific cases (will see later)
% - general linear speedup even with the overhead and without benefits of memoization
% (e.g., see Fibonacci example)

\subsection{Implementation considerations}
\label{sec:evalenv_impl_considerations}

% considerations between different forms of the data structures
% e.g., evalenv storing results vs. storing plain dhexp, unwrapping vs. rejudging indet/boxedvalue

% TODO: discussion of data structures used in the implementation and theoretical bounds (appendix or not?)
% - e.g., lists vs. maps vs. hashtables (structural sharing)

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End: