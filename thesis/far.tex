\chapter{Implementation of fill-and-resume}
\label{sec:far_impl}

\section{Motivation}
\label{sec:far-motivation}

Consider the program shown in \Cref{fig:far-motivation}. In this program, the calculation of $x=\text{fib }30$ is arbitrarily chosen to represent a computationally-expensive operation. The result of this program is \[
  [f\leftarrow [\varnothing]\lambda x.\{\dots\},x\leftarrow 832040]\hehole^1
\]
Now, if we want to ``fill'' hole 1 with the expression $x+2$, then it would seem wasteful to have to re-compute the value of $x$. After all, the computation bound to $x$ is exactly the same. Moreover, we realize that the evaluation result stores the computed value of $x$ in the hole's closure's environment. Rather than re-evaluating the original program, we may instead \textit{fill} the hole in the evaluated program result, and then \textit{resume} evaluation.
\begin{gather*}
  [f\leftarrow [\varnothing]\lambda x.\{\dots\},x\leftarrow 832040](x+2) \\
  832040+2 \\
  832042
\end{gather*}
Here we observe that the generalized closures surrounding holes and other stopped evaluations allow us to capture the environment for future computation.

\begin{listing}
  \centering
  \inputhminted{far_motivation}
  \caption{A sample program with an expensive calculation stored in a hole's environment}
  \label{fig:far-motivation}
\end{listing}

This is the \textit{fill-and-resume} (\textit{FAR}) operation that is described in Hazelnut Live \cite{conf/popl/HazelnutLive19}. It is described in terms of a substitution-based evaluation semantics, and with respect to its theoretic foundations in contextual modal type theory (CMTT). We provide the first implementation of such an operation. Hazelnut Live also describes a practical problem with fill operations that take place over multiple edit actions ($n$-step FAR), with the suggestion to ``cache more than one recent edit state to take full advantage of hole filling.'' We present a structural diffing\footnote{``Diffing'' taken to mean the action of performing a (structural) diff operation between two edit states.} algorithm in \Cref{sec:far-detect-structural-diff} that easily allows us to detect and fill a hole from an arbitrary past edit state.

\section{The FAR process}
\label{sec:far-process}

The fill-and-resume process can be broken into the following sequence.

\begin{enumerate}
\item Obtain a previous edit state with which to fill from the model.
\item Determine whether a fill operation is appropriate. If it is not, perform regular evaluation of the program, and do not continue to the following steps.
\item If the fill operation is valid, then obtain the fill parameters (the internal expression to fill, and the hole number from the previous edit state with which to fill).
\item \textbf{Fill.} Pre-process the evaluation result to prepare for (re-)evaluation.
\item \textbf{Resume.} Re-evaluate.
\item Pos-process the evaluation result for display purposes.
\item Update the model with the evaluation results.
\end{enumerate}

These steps will be described in greater detail in the following sections.

\subsection{Detecting the fill parameters via structural diff}
\label{sec:obtaining-fill-parameters}

Following the notation from \cite{conf/popl/HazelnutLive19}, the fill operation $\far{\dfill}{\ufill}{\dresult}$ indicates the fill of hole $\ufill$ with expression $\dfill$ in the expression $\dresult$. $\dresult$ is the past program result with which to fill. We need a method to determine the fill parameters $\ufill$ and $\dfill$.

\subsubsection{A na\"ive algorithm for detecting fill parameters}
\label{sec:far-detect-naive}

One way to approach the problem of obtaining the hole number and filled expression is at action time. When constructing an expression, we can check if the cursor lies in a hole (either directly in an empty hole, or if there is an ancestor non-empty hole). When deleting an expression, we can check if the cursor lies in a non-empty hole. However, this method is somewhat short-sighted. What happens if we wish to make multiple edits, e.g., fill a hole with the number 12? Then there are two actions, and the second action is not a hole fill action.
\begin{gather*}
  \hehole^1 \\
  1 \\
  12
\end{gather*}
We may remedy this specific case by grouping together consecutive construction actions\footnote{Grouping together of actions is already performed to some level by the undo history, for visual purposes.}. However, we may also consider more complicated edit sequences that involve movement and deletion actions, potentially outside of the hole. Consider the following edit sequence.
\begin{gather*}
  2+3*\hehole^1 \\
  2+\hehole^2*\hehole^1\\
  2+\hehole^1\\
  2+5 \\
  2+(5) \\
  2+\hehole^1*(5) \\
  2+3*(5) \\
  2+3*(5+\hehole^1)
\end{gather*}
The final edit state in this sequence is actually a valid fill of the first edit state of the sequence\footnote{There are actually multiple valid fill operations here. Another valid fill operation occurs between the third edit state and all of the following edit states.}, such that $u=1$ and $d=5+\hehole^1$. However, an algorithm to trace the edit actions to determine that this is a valid fill may be difficult, since there is an incomprehensible mix of construct, delete, and movement edit actions. Even worse, the edits traverse outside the original hole, which likely makes the algorithm intractable.

This method is only tractable for 1-step FAR or simple cases of grouped edit actiosn. We wish for a more robust yet still simple solution that is independent of the edit sequence between two states.

\subsubsection{Structural diffing between two edit states}
\label{sec:far-detect-structural-diff}

Instead of observing the edit action, we may instead attempt to find the root of the difference between any two edit states, and determine if that is the the difference gives valid fill parameters. This has the benefit of being a relatively simple algorithm, while overcoming the limitation of the previous method and allowing for $n$-step FAR.

The structural diff algorithm takes two expressions as input and returns one of three diff judgments\footnote{The following notations for diffing are chosen somewhat arbitrarily. The triangle seems appropriate because it has a variant with an equals bar ($\nodiff{}{}$), as well as a ``no fill'' ($\nfdiff{}{}{}{}$) and ``fill'' variant ($\fdiff{}{}{}{}$). The triangle is also horizontally asymmetric, which mirrors the fact that the diff relation is asymmetric.}. $\nodiff{d_1^-}{d_2^-}$ indicates \textit{no diff} between $d_1$ and $d_2$. $\nfdiff{d_1^-}{d_2^-}$ indicates a \textit{non-fill diff} from $d_1$ to $d_2$. $\fdiff{d_1^-}{d_2^-}{u^+}{d^+}$ indicates a \textit{fill diff} of hole $u$ with expression $d$ from $d_1$ to $d_2$.

We also define two shorthand operators for notational convenience. $\sdiff{d_1^-}{d_2^-}{u^+}{d^+}$ indicates \textit{some (non-empty) diff} from $d_1$ to $d_2$, which may or may not be a fill difference. $\adiff{d_1^-}{d_2^-}{u^+}{d^+}$ indicates \textit{any diff} (potentially no diff). Both notations are used to avoid writing multiple similar rules, where the only change in the rules is diff judgment type. The behavior of these notations is described in \Cref{fig:diff-abbrev}.

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{diff_abbrev}
    \end{singlespace}
  \end{mdframed}
  \caption{Structural diffing abbreviated judgments}
  \label{fig:diff-abbrev}
\end{figure}

For convenience, we define the judgment\footnote{The relation $\sim$ is already defined to mean type consistency when applied to types. This interpretation applies when the relation is applied to internal expressions.} $\formsame{d_1^-}{d_2^-}$ to mean that $d_1$ and $d_2$ are of the same \textit{expression form}. We use the term expression form or \textit{expression variant} to indicate the variant types of \mintinline{ocaml}|DHExp.t|. For example, empty holes and constants of the base type are different expression forms. Empty holes and non-empty holes are also different forms per the grammar. The rules shown in \Cref{fig:form-equal} should require no further explanation.

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{form_equal}
    \end{singlespace}
  \end{mdframed}
  \caption{Form equality judgment}
  \label{fig:form-equal}
\end{figure}

We divide up the structural diffing algorithm into cases based on expression forms.

\begin{description}
\item[Expressions with different forms] If the two expressions have different forms, then the current node is necessarily the diff root. It is a fill diff iff the left expression is a hole (DFNEqEHole, DFNEqNEHole, DFNEqNonHole).

  These rules are shown in \Cref{fig:structural-diff-diff}.
  
\item[Expressions with the same non-hole form] If the two expressions have the same form, then we need to check the root node and its subexpression(s). For expressions with no subexpressions, there is a non fill diff iff the expressions differ (DFEqConstNEq, DFEqConstEq, DFEqVarNEq).
  
  For expressions with a single subexpression, we first check if there are any differences, ignoring the subexpression. If there is a difference, then the current node is the non fill diff root. Otherwise, we pass through the diff from the child node (DFEqLamNEq$_1$, DFEqLamNEq$_2$, DFEqLamEq, DFEqAscNEq, DFEqAscEq).

  The last case to check for non-hole expressions are expressions with more than one subexpression. In this case, we first check if there exist any differences outside the subexpressions, which would result in a non fill diff rooted at the current node. Otherwise, if there are no subexpression diffs, then the result is no diff. If more than one subexpression has a diff, then the diff is a non fill diff rooted at the current node. The last case is when exactly one child has a diff, which would be passed through. This is the case for the binary function application expression form (DFEqApEq$_1$, DFEqApEq$_2$, DFEqApEq$_3$, DFEqApEq$_4$).

  In the minimal $\lambda$-calculus grammars specified for Hazel, the only expression form of plural subexpression arity is function application, but the following description extends to higher numbers of subexpressions (such as the case for \mintinline{ocaml}|case| expressions with arbitrary numbers of rules.

  These rules are shown in \Cref{fig:structural-diff-non-holes}.

\item[Expressions with the same hole form] The last case to consider is the comparison of two hole expressions of the same form. The empty hole case is very similar to the nullary subexpression case (DFEqEHoleNEq, DFEqEHoleEq). The non-empty hole case is very similar to the unary subexpression case (DFEqNEHoleNEq, DFEqNEHoleEq$_1$, DFEqNEHoleEq$_2$), except for a special rule that propagates non-fill diffs upwards to be a fill diff rooted in the current hole (DFEqNEHoleEqProp). This allows for diffs that are not rooted directly in a hole to be filled in their nearest non-empty hole parent node.

  These rules are shown in \Cref{fig:structural-diff-holes}.
\end{description}
The diff algorithm begins by performing the structural diff between the elaborated program state of a past edit state $d_{old}$ and the current edit state $d_{cur}$. A FAR operation is only valid if the diff judgment is a fill diff $\fdiff{d_{old}}{d_{cur}}{u}{d}$, which gives us the FAR parameters $u$ and $d$.

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{structural_diff_diff}
    \end{singlespace}
  \end{mdframed}
  \caption{Structural diffing of different expression forms}
  \label{fig:structural-diff-diff}
\end{figure}

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{structural_diff_non_holes}
    \end{singlespace}
  \end{mdframed}
  \caption{Structural diffing of non-hole expressions}
  \label{fig:structural-diff-non-holes}
\end{figure}

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{structural_diff_holes}
    \end{singlespace}
  \end{mdframed}
  \caption{Structural diffing of hole expressions}
  \label{fig:structural-diff-holes}
\end{figure}

\subsubsection{Performance tradeoffs of the two detection algorithms}
\label{sec:far-detect-compare}

In the most na\"ive form, the previous algorithm's efficiency is $O(\log E)$, where $E$ is the number of expression nodes in the program, if we assume that the depth of an expression node is logarithmic with respect to the total number of expression nodes. That algorithm only has to traverse up the ancestors to decide whether the edit lies in a hole.

The structural diff algorithm presented in this section is $O(E)$, since it traverses each node (once) until it finds a difference. However, if one travels backwards multiple edit states, then the cost is $O(SE)$, where $S$ is the number of edit states compared using this algorithm. While this is much more expensive than the previous algorithm, we assume that the program size is relatively small, causing delay only on the order of milliseconds. However, it may be able to find a valid fill-and-resume in many more cases than the previous algorithm, potentially saving a much longer repeated evaluation time.

\subsection{``Fill'': pre-processing the evaluation result for re-evaluation}
\label{sec:far-preprocessing}

Before beginning the re-evaluation, we would like to substitute all instances of the hole in the previous evaluation result $\dresult$ with the substituted expression. Each time a the hole $\ufill$ is encountered, it is replaced with the fill expression $\dfill$. This way, we can simply reinvoke the evaluation function on the past program result and expect it to resume the evaluation.

There are a few nuances here that should be addressed. First of all, we acknowledge another benefit of the generalized closure variant. If the environment was still baked into the hole, and the hole was replaced with an expression, we would need an additional mechanism to remember the hole's environment. This becomes more messy when the hole doesn't lie directly in a hole closure (i.e., if the hole lies outside the evaluation boundary). Closures are simply recursed through in this pre-processing step, and their environments will still be available even when the hole gets replaced with the fill expression.

We note that the pre-processing acts on the un-post-processed previous evaluation result $\dresult$. This is because the internal expression directly from evaluation and the result after post-processing have different properties or invariants. We do not want to invalidate the properties that are expected to be upheld during evaluation, such as the fact that the body of any $\lambda$-abstraction lies outside the evaluation boundary (whereas post-processing will modify function bodies).

Another issue to tackle is the problem that closures were previously considered to be final values, and would not be re-evaluated. Technically, we may re-evaluate closures; since the evaluation function is idempotent, this will not yield the incorrect result, but it is needlessly inefficient. However, we will need to re-evaluate closures during FAR re-evaluation, since the fill expression will necessarily lie within some closure.

\todo{write the previous statement as a metatheorem}

For efficiency reasons, we will only want to re-evaluate all closures in the result exactly once. To do this, we set a flag for the closure that indicates that it should be re-evaluated. This preprocessing step will recurse through $\dresult$ and set the flag to true for all closures. All closures that result from an evaluation judgment will have the flag set to false. Only closures with the re-eval flag set will be re-evaluated. Closures with the re-eval flag set to false will act as values and evaluate to themselves, which is the same as the original evaluation behavior described in \Cref{sec:generalized-closures-eval-boundary}. We denote closures with the re-eval flag set to false using the established notation for closures $[\env]d$\footnote{This allows previous discussions of closures to remain valid, since they take the interpretation that the re-eval flag is set to false.}, and denote closures with the re-eval flag set to true by $\llbracket\env\rrbracket d$\footnote{Using the double-square bracket notation also reinforces the fact that re-evaluation is tied with fill-and-resume, which also uses double-square brackets.}.

Finally, we may consider the issue of multiple instances of the same hole closure\footnote{Hole closure refers to the connotation from \Cref{sec:instance-illustration}: instances of hole $\ufill$ that share the same (physical) environment.}. If we substitute the hole, then we lose the information about the holes instance, and thus cannot memoize the evaluations of the same hole instance by environment number. A solution to this is to introduce another \mintinline{ocaml}|DHExp.t| variant \mintinline{ocaml}|FillExp(HoleClosureId.t, DHExp.t)| that indicates the hole closure number as well as the expression to fill. This will be denoted using a hole with a subscript $\hhole{d}_i$. The preprocessing expression will fill a hole $\ufill$ with this expression rather than the expression $\dfill$ directly. During evaluation, this data structure will facilitate the memoization of hole closures.

\subsection{``Resume'': Modifications to allow for re-evaluation}
\label{sec:re-eval}

Re-evaluation during fill-and-resume is mostly the same as regular evaluation, but now we need to keep in mind the considerations from pre-processing the previous program result.

The updated evaluation rules for closures are shown in \Cref{fig:reeval-closures}. All closures in the evaluation result will have been marked for re-evaluation by the pre-processing step. This means that the closure environment will first be recursively re-evaluated, following by the closure body. This ensures that the entire program result is fully evaluated\footnote{Note that there is now an ``inversion'' of evaluation order, in that we cannot expect the environment to be fully evaluated before it is encountered in a closure. In an ordinary evaluation, we would expect all the bindings in the environment to have been evaluated before they have been stored in the environment.}. We introduce a (re-)evaluation judgment for environments $\env^-\Downarrow\env'^+$, which simply maps the evaluate operation over the bindings of an environment. Closures with the re-eval flag set to false will have the regular evaluation rule.

\todo{metatheorem about how all closures from $\dresult$ will re-evaluated (exactly once), assuming that evaluation terminates}

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{reeval_closures}
    \end{singlespace}
  \end{mdframed}
  \caption{Revised evaluation rules for closures}
  \label{fig:reeval-closures}
\end{figure}

The other difference that we have to deal with are memoizing the evaluation of the filled hole expressions. Per the discussion of the pre-processing step, all filled expressions will exist in a wrapper that indicates the hole number. We may simply memoize the results by that hole number. This requires us to thread some state throughout our evaluation\footnote{Luckily, threading state through evaluation is useful for other purposes as well, such as keeping track of the current \mintinline{ocaml}|EvalEnvId.t|, and keeping track of evaluation state. These are grouped together under one data structure, \mintinline{ocaml}|EvalState.t|, for ease of implementation.}.

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{fill_memoized_resume}
    \end{singlespace}
  \end{mdframed}
  \caption{Fill-memoized re-evaluation}
  \label{fig:fill-memoized-resume}
\end{figure}

In these judgments, we introduce a new \textit{fill memoization context} $\fenv:i\mapsto d$, a mapping of hole closure numbers to expressions\footnote{The symbol $\fenv$ was chosen arbitrarily. It is simply the Greek letter before $\env$.}. A new \textit{fill-memoized evaluation judgment} $\env^-,\fenv^-\vdash d^-\Downarrow d'^+\dashv\fenv'^+$ describes the evaluation with memoization of hole fills. When a hole closure number is encountered for the first time, the expression is evaluated normally and added to $\fenv$; otherwise, the evaluated result of the fill is simply looked up from $\fenv$. Note that memoization requires $\fenv$ to be threaded throughout the evaluation, i.e., it is treated both as an input and output of the evaluation judgment.

This fill-memoized evaluation judgment subsumes the normal evaluation judgment. For all non-hole-fill expressions, it performs the normal evaluation judgment and returns the fill memoization context unchanged.

\subsection{Post-processing resumed evaluation}
\label{sec:far-postprocessing}

The postprocessing algorithm remains unchanged from before. Note that an evaluated program result should never include either of the new forms $\hhole{d}_i$ or $\llbracket\env\rrbracket d$; these should all have been encountered and evaluated out. In other words, the evaluation result from re-evaluation during a FAR should be indistinguishable from the evaluation result from a regular evaluation, and thus the postprocessing process is unchanged.

\todo{metatheorems to back up the above}

\section{Entrypoint to the FAR algorithm}
\label{sec:far-entrypoint}

\begin{figure}
  \centering
  \input{previous_evaluation_call_graph}
  \caption{Previous action call graph}
  \label{fig:prev-evaluation-call-graph}
\end{figure}

\begin{figure}
  \centering
  \input{current_evaluation_call_graph}
  \caption{Current action call graph}
  \label{fig:current-evaluation-call-graph}
\end{figure}

An abstracted call graph for the action model (the process of responding to an action, up to evaluation) in Hazel is diagramed in \Cref{fig:prev-evaluation-call-graph}. Red boxes indicate important data structures. Black boxes indicate important steps in the process of responding to an action. The lines between boxes roughly indicate the flow of the program and other important data structures related to the process.

An edit action triggers the bidirectional action semantics, which generates an updated program edit state. This is then elaborated to an internal expression, evaluated, and then postprocessed. The results of evaluation are stored in \mintinline{ocaml}|Result.t|.

The updated abstract call graph is shown in \Cref{fig:current-evaluation-call-graph}. Fill and resume is fundamentally an operation on internal expressions, so we attempt to detect a hole fill operation after elaboration of the current edit state. The structural diff operation requires information about at least one previous edit state from the model's \mintinline{ocaml}|UndoHistory.t|. The result of the previous evaluation is preprocessed, before being evaluated (using the updated evaluation judgments) and postprocessed as usual.

Since this is a very high-level view of the program, many details are abstracted out. For example, the evaluation function is memoized by the function \mintinline{ocaml}|Program.get_result|, which facilitates the normal evaluation process. We will need to modify this memoization to also memoize the FAR evaluation results.

\section{FAR examples}
\label{sec:far-examples}

\subsection{Motivating example}
\label{sec:far-motivating-example}

We revisit the program from \Cref{fig:far-motivation}, reproduced in \Cref{fig:far-simple-reproduced}. This hole fill operation is very simple, replacing a hole with a value. We also observe the behavior of the preprocessing operation, which marks closures for re-evaluation and encapsulates filled expressions with the hole closure number for memoization.

\begin{figure}
  \centering
  \begin{singlespace}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputhminted{far_simple}
        \caption{Previous edit state}
        \label{fig:far-simple-reproduced}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputhminted{far_simple_filled}
        \caption{Filled edit state}
      \end{subfigure}
    }
    \vspace{10pt}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          [x\leftarrow 832040]\hehole^{1:1}
        \end{equation*}
        \caption{Previous program result}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          u=1, d=x+2
        \end{equation*}
        \caption{Detected fill parameters}
      \end{subfigure}
    }
    \vspace{10pt}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          \llbracket x\leftarrow 832040\rrbracket\hhole{x+2}_1
        \end{equation*}
        \caption{Preprocessed program result}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          832042
        \end{equation*}
        \caption{Resumed program result}
      \end{subfigure}
    }
  \end{singlespace}
  \caption{FAR simple example}
  \label{fig:far-simple-example}
\end{figure}

\subsection{Introducing and removing static type errors}
\label{sec:far-static-error-examples}

Now, consider the program shown in \Cref{fig:far-introduce-type-error}. In this fill operation, we introduce a new static type error (non-empty hole). The non-empty hole is inserted automatically during the action semantics and appears naturally in the diff, so we do not need to perform any special handling for it. Similarly, in the case of \Cref{fig:far-remove-type-error}, a non-empty hole is removed by filling with a type-consistent expression. This allows static type errors to be ``fixed'' and evaluation to resume past where it had stopped.

\begin{figure}
  \centering
  \begin{singlespace}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputhminted{far_introduce_type_error}
        \caption{Previous edit state}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputhminted{far_introduce_type_error_filled}
        \caption{Filled edit state}
      \end{subfigure}
    }
    \vspace{10pt}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          2+[\varnothing]\hehole^1
        \end{equation*}
        \caption{Previous program result}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          u=1,d=\hhole{\lambda x.x}^{1:1}
        \end{equation*}
        \caption{Detected fill parameters}
      \end{subfigure}
    }
    \vspace{10pt}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          2+\llbracket\varnothing\rrbracket\hhole{\hhole{\lambda x.x}^1}_1
        \end{equation*}
        \caption{Preprocessed program result}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          2+[\varnothing]\hhole{[\varnothing]\lambda x.x}^{1:1}
        \end{equation*}
        \caption{Resumed program result}
      \end{subfigure}
    }
  \end{singlespace}
  \caption{FAR introduce static type error example}
  \label{fig:far-introduce-type-error}
\end{figure}

\begin{figure}
  \centering
  \begin{singlespace}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputhminted{far_remove_type_error}
        \caption{Previous edit state}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputhminted{far_remove_type_error_filled}
        \caption{Filled edit state}
      \end{subfigure}
    }
    \vspace{10pt}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          2+[\varnothing]\hhole{[\varnothing]\lambda x.x}^{1:1}
        \end{equation*}
        \caption{Previous program result}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          u=1, d=3
        \end{equation*}
        \caption{Fill parameters}
      \end{subfigure}
    }
    \vspace{10pt}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          2+\llbracket\varnothing\rrbracket\hhole{3}_1
        \end{equation*}
        \caption{Preprocessed program result}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          5
        \end{equation*}
        \caption{Resumed program result}
      \end{subfigure}
    }
  \end{singlespace}
  \caption{FAR remove static type error example}
  \label{fig:far-remove-type-error}
\end{figure}

\subsection{Example requiring recursive evaluation of closure environment}
\label{sec:far-closure-recursion-example}

In \Cref{fig:far-fill-hole-in-hole-env} we fill a hole that does not exist directly in the result, but exists in a hole closure environment. This illustrates the need to recursively re-evaluate closure environments.

\begin{figure}
  \centering
  \begin{singlespace}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputhminted{far_fill_in_hole_env}
        \caption{Previous edit state}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputhminted{far_fill_in_hole_env_filled}
        \caption{Filled edit state}
      \end{subfigure}
    }
    \vspace{10pt}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          [x\leftarrow[\varnothing]\hehole^{1:1}]\hehole^{2:1}
        \end{equation*}
        \caption{Previous program result}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          u=1, d=2
        \end{equation*}
        \caption{Fill parameters}
      \end{subfigure}
    }
    \vspace{10pt}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          \llbracket x\leftarrow\llbracket\varnothing\rrbracket\hhole{2}_1\rrbracket\hehole^{2:1}
        \end{equation*}
        \caption{Preprocessed program result}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          [x\leftarrow 2]\hehole^{2:1}
        \end{equation*}
        \caption{Resumed program result}
      \end{subfigure}
    }
  \end{singlespace}
  \caption{FAR fill hole in hole environment example}
  \label{fig:far-fill-hole-in-hole-env}
\end{figure}

\subsection{Hole fill expression memoization example}
\label{sec:far-hole-fill-memoization-example}

The program in \Cref{fig:far-hole-closure-memoization} shows the necessity of memoizing by hole closure number, in order to preserve the same result as if evaluating normally. In this example, we have two instances of hole 1 in the result. Since there is only one instantiation of hole 1, these are two instances of the same hole closure. If there were no memoization of filled expressions, then the filled expression $f\ 1$ would be evaluated twice. This is problematic because function application generates new environments (and new environment identifiers), so the two instances would have different closures and thus be considered two separate hole closures, even when they come from the same instantiation. Since the filled expression is memoized, the two instances of the hole have closures with the same environment identifier (indicated by the same superscript $i$ on the closure environments).

The necessity of memoization in this case is related to the idea of the ``inversion'' of evaluation mentioned in \Cref{sec:re-eval}: during normal evaluation, we expect that a variable may be referenced in multiple places after it is evaluated. However, during a resumed evaluation, we may encounter multiple unevaluated instances of the same instantiation; the first time it is encountered and evaluated is the de facto ``first instantiation'' of that expression.

\begin{figure}
  \centering
  \begin{singlespace}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputhminted{far_hole_closure_memoization}
        \caption{Previous edit state}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputhminted{far_hole_closure_memoization_filled}
        \caption{Filled edit state}
      \end{subfigure}
    }
    \vspace{10pt}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{gather*}
          [f\leftarrow[\varnothing]\lambda x.\{\hehole^{1:1}\}]\hehole^{2:1} \\
          + \\
          [f\leftarrow[\varnothing]\lambda x.\{\hehole^{1:1}\}]\hehole^{2:1}
        \end{gather*}
        \caption{Previous program result}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{equation*}
          u=2, d=f\ 1
        \end{equation*}
        \caption{Fill parameters}
      \end{subfigure}
    }
    \vspace{10pt}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{gather*}
          \llbracket f\leftarrow\llbracket\varnothing\rrbracket\lambda x.\{\hehole^{1:1}\}\rrbracket\hhole{f\ 1}_1 \\
          + \\
          \llbracket f\leftarrow\llbracket\varnothing\rrbracket\lambda x.\{\hehole^{1:1}\}\rrbracket\hhole{f\ 1}_1
        \end{gather*}
        \caption{Preprocessed program result}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \begin{gather*}
          [x\leftarrow 1]^i\hehole^{1:1}
          +
          [x\leftarrow 1]^i\hehole^{1:1}
        \end{gather*}
        \caption{Resumed program result}
      \end{subfigure}
    }
  \end{singlespace}
  \caption{FAR hole closure memoization example}
  \label{fig:far-hole-closure-memoization}
\end{figure}

\subsection{Noteworthy non-examples}
\label{sec:far-nonexamples}

\subsubsection{Dynamic type errors}
\label{sec:far-dynamic-type-errors}

One may wonder if dynamic type errors (cast failure) have any nice relation to fill-and-resume, but it turns out that they are not treated much different than other non-hole expressions. We may not fill a cast failure directly, because it is not in a hole. We may only remove a cast failure if it lies in a non-empty hole that is filled.

We may introduce new cast failures by filling an expression that is assigned to type hole (something of dynamic type). However, this is no different than introducing any well-typed expression and performing normal evaluation.

Thus the only interesting cases of introducing or remoing holes lies in the case of static type errors (non-empty holes) as described previously.

\subsubsection{Infix operators}
\label{sec:far-infix-operators}

Filling holes in an infix operator sequence may not result in a hole fill due to infix operator precedences, despite the initial appearance. Consider the example shown in \Cref{fig:far-infix-operator-fill}. Say we construct a binary plus operator in the hole. One might expect the fill operation to be $\far{\hehole^2+\hehole^1}{1}{\dresult}$. However, we need to be careful: the multiplication operator has a higher precedence than the addition operator, causing the AST to have a different structure outside of where hole 1 was in the original edit state. It may be more clear if we write the latter edit state with its implicit parentheses: \hmintinline{(1 * /\heh2/) + (/\heh1/ * 2)}.

If, however, hole 1 in the original edit state was a parenthesized expression, and the sum expression shape was constructed inside the parenthesized expression, then the AST wouldn't change (as a parenthesized expression has higher precedence than the outer multiplication operation) and it would be a valid fill operation.

\begin{figure}
  \centering
  \begin{singlespace}
    \makebox[\textwidth][c]{
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputhminted{far_infix_operators}
        \caption{Previous edit state}
      \end{subfigure}
      \qquad
      \begin{subfigure}[b]{0.4\paperwidth}
        \inputhminted{far_infix_operators_filled}
        \caption{Filled edit state}
      \end{subfigure}
    }
  \end{singlespace}
  \caption{FAR infix operator fill}
  \label{fig:far-infix-operator-fill}
\end{figure}

\section{Tracking evaluation state}
\label{sec:eval-state}

It may be useful to thread some state throughout the evaluation process. This means that changes to this state by an earlier invocation to evaluate will affect later evaluations.

The concept of keeping state has already appeared in several contexts. For postprocessing, the memoized hole closure info keeps track of seen environments (\Cref{sec:memoization}). For evaluation, we keep track of the next unique environment identifier and memoize the evaluation of filled expressions (\Cref{sec:re-eval}). A theoretical discussion is revisited in \Cref{sec:env-purity}.

This becomes relevant again (with respect to evaluation) because resuming evaluation requires us to store the state after evaluation, and restore the state after evaluation. Adding more state variables also makes the implementation messier by increasing the number of variables to pass to and return from each of the numerous calls to \mintinline{ocaml}|Evaluator.evaluate|.

The nice solution to this is to group together all evaluation state under a single data structure, \mintinline{ocaml}|EvalState.t|. This one state variable is passed around to all calls to evaluate, and is stored to and restored from \mintinline{ocaml}|Result.t|, which stores all information about a program's evaluated result (including the evaluated expression and the hole closure information). Adding state then becomes trivial, because we only have to modify this data structure rather than all of the calls to \mintinline{ocaml}|Evaluator.evaluate|.

For sake of brevity, we will not update the judgments to include this state.

\subsection{Step counting}
\label{sec:step-counting}

With the \mintinline{ocaml}|EvalState.t| data structure, it is now trivial to keep track of evaluation statistics. Sample statistics might include step counting and number of times a particular evaluation trace has been paused and resumed.

Step counting may be implemented simply by incrementing the count on each call to \mintinline{ocaml}|Evaluator.evaluate|. This may be useful to stop long-running executions after a particular number of (possibly user-specified) execution steps in order to prevent program crashes. It is also useful for our purposes to track how efficient fill-and-resume is: during a fill operation, one may observe the difference in the number of steps before and after the resumed evaluation, and compare it to the case if the evaluation had begun from scratch.

\section{Differences from the substitution model}
\label{sec:far-sub}

The FAR operation is much simpler when evaluating with substitution rather than with environments. With substitution, we eliminate the need for pre- and post-processing steps, and dealing with re-evaluating closures. However, this comes at the cost of not being able to memoize repeated instances of the same hole closure. The original description of FAR from \cite{conf/popl/HazelnutLive19} is reproduced in \Cref{fig:far-substitution}. The equals (=) operator is used to indicate the FAR operation here; it is meant to symbolize the mix of substitution and evaluation that is presented here. The hole closure notation from \cite{conf/popl/HazelnutLive19}, in which the hole closure is represented using a subscript, is also used here, since the substitution model doesn't have the concept of separate closures.

\begin{figure}
  \centering
  \begin{mdframed}
    \begin{singlespace}
      \input{far_substitution}
    \end{singlespace}
  \end{mdframed}
  \caption{FAR using the substitution model, reproduced from \cite{conf/popl/HazelnutLive19}}
  \label{fig:far-substitution}
\end{figure}

What remains the same between the environment model and the substitution model is the need for an algorithm to detect the fill parameters, for which the structural diff algorithm presented in \Cref{sec:far-detect-structural-diff} is still applicable.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
