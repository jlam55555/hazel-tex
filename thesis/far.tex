\chapter{Implementation of fill-and-resume}
\label{sec:far_impl}

% General steps:
% Determine that the last edit action only involves changes within a hole
% - May go multiple steps back (memoization)
% Elaborate the expression to substitute in
% Determine if the synthesized type of the expression matches that of the hole (from the hole context)
% - Multiple cases here
% Evaluate each instance of the hole
% Update it in each of its parent hole closures
% Update it in the result
% Remove hole closure from HCC

% More consistent to consider the end result as contained within a top-level hole,
% as if our program were always incomplete (perhaps, philosophically)

% TODO: walk through a few examples by hand
% - Introduce new type inconsistencies
% - Remove old type inconsistencies
% - No new type (in)consistencies
% - Multiple hole instances
% - Multiple parent hole instances

\section{Motivation}
\label{sec:far-motivation}

\begin{figure}
  \centering
  \inputhminted{far_motivation}
  \caption{A sample program with an expensive calculation stored in a hole's environment}
  \label{fig:far-motivation}
\end{figure}

Consider the program shown in \Cref{fig:far-motivation}. In this program, the calculation of $x=\text{fib }30$ is arbitrarily chosen to represent a computationally-expensive operation. The result of this program is \[
  [f\leftarrow [\varnothing]\lambda x.\{\dots\},x\leftarrow 832040]\hehole^1
\]
Now, if we want to ``fill'' hole 1 with the expression $x+2$, then it would seem extremely wasteful to have to re-compute the value of $x$. After all, the computation remains exactly the same, and the only part that we are changing uses the result of the previous computation. Moreover, we realize that the end result stores the computed value of $x$ in the hole's closure's environment. Rather than filling the expression $x+2$ in the hole in the original program, we may instead fill the hole in the evaluated program result, and ``resume'' evaluation.
\begin{gather*}
  [f\leftarrow [\varnothing]\lambda x.\{\dots\},x\leftarrow 832040](x+2) \\
  832040+2 \\
  832042
\end{gather*}
Here we observe that the generalized closures surrounding holes and other stopped evaluations allow us to capture the environment for future computation.

This is the \textit{fill-and-resume} (\textit{FAR}) operation that is described in Hazelnut Live \cite{conf/popl/HazelnutLive19}. It is described in terms of a substitution-based evaluation semantics, and with respect to its theoretic foundations in contextual modal type theory (CMTT), but does not specify any details with regard to its implementation, such as the extraction of the expression and hole for the fill operation. Hazelnut Live also describes the practical memoization problem with the suggestion to ``cache more than one recent edit state to take full advantage of hole filling'' -- we present a structural diffing\footnote{``Diffing'' taken to mean the action of performing a (structural) diff operation between two edit states.} algorithm that easily allows us to fill a hole from an arbitrary past edit state.

\section{Re-evaluation of closures}
\label{sec:reeval-flag}

\todo{implement this section}

% \section{CMTT interpretation of fill-and-resume}
% \label{sec:implementing-far}

% \section{Memoization of recent actions} 
% \label{sec:memoization-actions}

% \section{UI changes for notebook-like editing}
% \label{sec:notebook-ui}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
