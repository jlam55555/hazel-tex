\chapter{Implementation of fill-and-resume}
\label{sec:far_impl}

\section{Motivation}
\label{sec:far-motivation}

\begin{figure}
  \centering
  \inputhminted{far_motivation}
  \caption{A sample program with an expensive calculation stored in a hole's environment}
  \label{fig:far-motivation}
\end{figure}

Consider the program shown in \Cref{fig:far-motivation}. In this program, the calculation of $x=\text{fib }30$ is arbitrarily chosen to represent a computationally-expensive operation. The result of this program is \[
  [f\leftarrow [\varnothing]\lambda x.\{\dots\},x\leftarrow 832040]\hehole^1
\]
Now, if we want to ``fill'' hole 1 with the expression $x+2$, then it would seem extremely wasteful to have to re-compute the value of $x$. After all, the computation remains exactly the same, and the only part that we are changing uses the result of the previous computation. Moreover, we realize that the end result stores the computed value of $x$ in the hole's closure's environment. Rather than filling the expression $x+2$ in the hole in the original program, we may instead fill the hole in the evaluated program result, and ``resume'' evaluation.
\begin{gather*}
  [f\leftarrow [\varnothing]\lambda x.\{\dots\},x\leftarrow 832040](x+2) \\
  832040+2 \\
  832042
\end{gather*}
Here we observe that the generalized closures surrounding holes and other stopped evaluations allow us to capture the environment for future computation.

This is the \textit{fill-and-resume} (\textit{FAR}) operation that is described in Hazelnut Live \cite{conf/popl/HazelnutLive19}. It is described in terms of a substitution-based evaluation semantics, and with respect to its theoretic foundations in contextual modal type theory (CMTT), but does not specify any details with regard to its implementation, such as the extraction of the expression and hole for the fill operation. Hazelnut Live also describes the practical memoization problem with the suggestion to ``cache more than one recent edit state to take full advantage of hole filling'' -- we present a structural diffing\footnote{``Diffing'' taken to mean the action of performing a (structural) diff operation between two edit states.} algorithm that easily allows us to fill a hole from an arbitrary past edit state.

\section{The FAR process}
\label{sec:far-process}

The fill-and-resume process can be broken into the following sequence.

\begin{enumerate}
\item Obtain a previous edit state with which to fill from the model.
\item Determine whether a fill operation is appropriate. If it is not, perform regular evaluation of the program, and do not continue to the following steps.
\item If the fill operation is valid, then obtain the fill parameters (the internal expression to fill, and the hole number from the previous edit state with which to fill).
\item Pre-process the evaluation result to prepare for (re-)evaluation.
\item Re-evaluate.
\item Pos-process the evaluation result for display purposes.
\item Update the model with the evaluation results.
\end{enumerate}

These steps will be described in greater detail in the following sections.

\subsection{Entrypoint to the FAR algorithm}
\label{sec:far-entrypoint}

\subsection{Detecting the fill parameters via structural diff}
\label{sec:obtaining-fill-parameters}

\subsubsection{A na\"ive algorithm for detecting fill parameters}
\label{sec:far-detect-naive}

One way to approach the problem of obtaining the hole number and filled expression is at action time. When constructing an expression, we can check if the cursor lies in a hole (either directly in an empty hole, or if there is an ancestor non-empty hole). When deleting an expression, we can check if the cursor lies in a non-empty hole. However, this method is somewhat short-sighted. What happens if we wish to make multiple edits, e.g., fill a hole with the number 12? Then there are two actions, and the second action is not a hole fill action.
\begin{gather*}
  \hehole^1 \\
  1 \\
  12
\end{gather*}
We may remedy this specific case by grouping together consecutive construction actions\footnote{Grouping together of actions is already performed to some level by the undo history, for visual purposes.}. However, we may also consider more complicated edit sequences that involve movement and deletion actions, potentially outside of the hole. Consider the following edit sequence.
\begin{gather*}
  2+3*\hehole^1 \\
  2+\hehole^2*\hehole^1\\
  2+\hehole^1\\
  2+5 \\
  2+(5) \\
  2+\hehole^1*(5) \\
  2+3*(5) \\
  2+3*(5+\hehole^1)
\end{gather*}
The final edit state in this sequence is actually a valid fill of the first edit state of the sequence\footnote{There are actually multiple valid fill operations here. Another valid fill operation occurs between the third edit state and all of the following edit states.}, such that $u=1$ and $d=5+\hehole^1$. However, an algorithm to trace the edit actions to determine that this is a valid fill may be difficult, since there is an incomprehensible mix of construct, delete, and movement edit actions. Even worse, the edits actually go outside the original hole, which likely makes the algorithm intractable. Thus, we wish for a more robust solution that is independent of the edit sequence between two states.

\subsubsection{Structural diffing between two edit states}
\label{sec:far-detect-structural-diff}

Instead of observing the edit action, we may instead attempt to find the root of the difference between any two edit states, and determine if that is the the difference gives valid fill parameters. This has the benefit of being a relatively simple algorithm, while overcoming the limitation of the previous method because it is path-independent.

The structural diff algorithm takes two expressions as input and returns one of three diff judgments\footnote{The following notations for diffing are chosen somewhat arbitrarily. The triangle seems appropriate because it has a variant with an equals bar ($\nodiff{}{}$), as well as a ``no fill'' ($\nfdiff{}{}{}{}$) and ``fill'' variant ($\fdiff{}{}{}{}$). The triangle is also horizontally asymmetric, which makes sense given that the diff operation is asymmetric.}. $\nodiff{d_1}{d_2}$ indicates \textit{no diff} between $d_1$ and $d_2$. $\nfdiff{d_1}{d_2}$ indicates a \textit{non-fill diff} from $d_1$ to $d_2$. $\fdiff{d_1}{d_2}{u}{d}$ indicates a \textit{fill diff} of hole $u$ with expression $d$ from $d_1$ to $d_2$.

We also define two shorthand operators for notational convenience. $\fnfdiff{d_1}{d_2}{u}{d}$ indicates \textit{some (non-empty) diff} from $d_1$ to $d_2$, which may or may not be a fill difference. $dff{d_1}{d_2}{u}{d}$ indicates \textit{any diff} (potentially no diff). Both notations are used to avoid writing multiple similar rules, where the only change in the rules is diff judgment type.

\todo{put the following in a figure, and move to another file}

\begin{singlespace}
  \judgbox{\fnfdiff{d_1}{d_2}{u}{d}}{Some (non-empty) diff between $d_1$ and $d_2$.}
  \begin{mathpar}
    \Infer{SDiffNFDiffSome}{
      \nfdiff{d_1}{d_2}
    }{\fnfdiff{d_1}{d_2}{\varnothing}{\varnothing}}
    \and
    \Infer{SDiffFDiffSome}{
      \fdiff{d_1}{d_2}{u}{d}
    }{\fnfdiff{d_1}{d_2}{u}{d}}
    \and
    \Infer{SDiffSomeNFDiff}{
      \fnfdiff{d_1}{d_2}{\varnothing}{\varnothing}
    }{\nfdiff{d_1}{d_2}}
    \and
    \Infer{SDiffSomeFDiff}{
      \fnfdiff{d_1}{d_2}{u}{d}
    }{\fdiff{d_1}{d_2}{u}{d}}
  \end{mathpar}

  \judgbox{\dff{d_1}{d_2}{u}{d}}{Any (possibly-empty) diff between $d_1$ and $d_2$.}
  \begin{mathpar}
    \Infer{ADiffNoDiffAny}{
      \nodiff{d_1}{d_2}
    }{\dff{d_1}{d_2}{\cdot}{\varnothing}}
    \and
    \Infer{ADiffNFDiffAny}{
      \nfdiff{d_1}{d_2}
    }{\dff{d_1}{d_2}{\varnothing}{\varnothing}}
    \and
    \Infer{ADiffFDiffAny}{
      \fdiff{d_1}{d_2}{u}{d}
    }{\dff{d_1}{d_2}{u}{d}}
    \and
    \Infer{ADiffAnyNoDiff}{
      \dff{d_1}{d_2}{\cdot}{\varnothing}
    }{\nodiff{d_1}{d_2}}
    \and
    \Infer{ADiffAnyNFDiff}{
      \fnfdiff{d_1}{d_2}{\varnothing}{\varnothing}
    }{\nfdiff{d_1}{d_2}}
    \and
    \Infer{ADiffAnyFDiff}{
      \fnfdiff{d_1}{d_2}{u}{d}
    }{\fdiff{d_1}{d_2}{u}{d}}
  \end{mathpar}
\end{singlespace}

\subsection{Performance tradeoffs of the two detection algorithms}
\label{sec:far-detect-compare}

In the most na\"ive form, the previous algorithm's efficiency is $O(\log E)$, where $E$ is the number of expression nodes in the program, if we assume that the depth of an expression node is logarithmic with respect to the total number of expression nodes. That algorithm only has to traverse up the ancestors to decide whether the edit lies in a hole.

The structural diff algorithm presented in this section is $O(E)$, since it traverses each node (once) until it finds a difference. However, if one travels backwards multiple edit states, then the cost is $O(SE)$, where $S$ is the number of edit states compared using this algorithm. While this is much more expensive than the previous algorithm, we assume that the program size is relatively small, causing delay only on the order of milliseconds. However, it may be able to find a valid fill-and-resume in many more cases than the previous algorithm, potentially saving a much longer repeated evaluation time.

\subsubsection{Choosing the edit state to fill from}
\label{sec:far-past-edit-states}

Past edit states are stored in an undo history in Hazel, which allows the user to quickly return to previous edit states. The structure of the undo history is complicated and Hazel-specific, and thus not described here. We note that the result of evaluation is not stored alongside the evaluation result, but the evaluation function itself is memoized, so retrieving a previous edit state and re-evaluating the program is typically not expensive.

\todo{note why that memoization won't work well for us anymore}

There are a number of possible design decisions when searching for a valid hole fill. Firstly, one must decide the maximum number of edit states to search: should it be a fixed number of edit states, or should it be given a fixed time budget? Is it best to cache edit states that recently led to a fill operation (\`a la LRU cache)? Is the most recent edit state that leads to a valid fill usually the best candidate, or even a good candidate? Would it be best to allow for user-configurable settings, or perhaps even for the user to manually select the previous edit from which to fill?

\todoref{need to create a future work section for this}

\subsection{Pre-processing the evaluation result for re-evaluation}
\label{sec:far-preprocessing}

\todo{executable flag on closures}

\subsection{Modifications to evaluation to allow for re-evaluation}
\label{sec:re-eval}

\todo{note: re-evaluate on un-postprocessed result, due to bodies of lambdas being evaluated in postprocessed result}

\todo{recursively evaluating closures: ``inversion'' of evaluation order, now cannot assume environments (which usually are evaluated previously) to be evaluated}

\todo{need to memoize hole environments in order to keep interpretation of unique hole instantiations, otherwise same hole instance will be evaluated multiple times (not implemented yet, future work)}

\subsection{Post-processing resumed evaluation}
\label{sec:far-postprocessing}

\todo{normal postprocessing, evaluated closures simply get expanded as usual}

\subsection{Storing the evaluation result in the model}
\label{sec:result-model}

\todo{memoization alongside Program.evaluate}

\subsection{Re-evaluation of closures}
\label{sec:reeval-flag}

\section{FAR examples}
\label{sec:far-examples}

\todo{non-empty holes are all treated the same}

\todo{static type error examples}

\todo{example where closure environment has to be recursively re-evaluated}

\todo{example where environment appears multiple times, has to be memoized for invariant to hold}

\section{Tracking evaluation state}
\label{sec:eval-state}

\todo{maybe move this to the results section?}

\todo{show step counts in UI; can stop evaluation after n steps}

\todo{what constitutes the evaluation state?}

\todo{also keep track of evaluation memoization}

\subsection{Noteworthy non-examples}
\label{sec:far-nonexamples}

\todo{dynamic type errors don't get solved with FAR}

\todo{note about infix operators}

\section{Differences from the substitution model}
\label{sec:far-sub}

\todo{reproduce the original description}

\todo{preprocessing is very much the same}

\todo{still have to memoize environments to keep the interpretation of unique hole instantiations}

\section{FAR for notebook-style editing}
\label{sec:notebook-ui}

\todo{improvements: reproducibility}

\todo{limitations: limited cases for re-evaluation}

\section{Improvements to FAR}
\label{sec:far-improvements}

\todo{move this to future work section}

\todo{need general cleanup of FAR implementation, not very complete}

\todo{optimizing how many edit states to go back: tradeoffs between storage (how many edit states to store) and speed (how much execution time to detect a FAR, how expensive is FAR depending on which edit state; currently the most recent edit state is used, something like a LRU; may want to cache recent edit states that spawned a FAR or group edit states like in the undo history currently)}

\todo{automatic vs manual far detection}

\section{Metatheorems governing FAR}
\label{sec:far-meta}

\todo{filling (from original paper)}

\todo{commutativity}

\todo{all closures will be evaluated exactly once -- this allows holes that have not yet been evaluated in the result to be successfully re-evaluated (assuming program terminates) and maintains the invariant that all closures will be evaluated at the end of evaluation}

\section{Generalized views on non-empty holes and FAR}
\label{sec:generalized-holes-far}

The work performed for FAR leads us to the following nice generalizations of some of the concepts we've encountered through this work.

\todo{perhaps move this to the discussion section, along with generalized holes from Ch4?}

\subsubsection{Generalized non-empty holes}
\label{sec:generalized-neholes}

\todo{every partially-complete program can be represented as part of a non-empty hole. In particular, top-level program can be considered to be in a non-empty hole to be filled. Also works nicely as a general parent (in HoleClosureInfo) for all holes in a non-complete program}

\subsubsection{Generalized FAR}
\label{sec:generalized-far}

\todo{every evaluation can be rewritten as a FAR operation, since every program originates from a hole as an initial state, or using the above version where the top-level expression exists in a non-empty hole}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
