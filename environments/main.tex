\documentclass{article}

% see readme
\def\OPTIONConf{1}%
\usepackage{joshuadunfield}
\usepackage{llproof}
\input{../latex-includes/macros.tex}

\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{hyperref}

\newtheorem{theorem}{Theorem}

\title{Evaluation with environments}
\author{Jonathan Lam}
\date{2022/01/03}

\begin{document}

\maketitle{}

\section{Motivation}

Evaluation with substitution is not efficient because it forces the re-evaluation of the substituted expression every time it is encountered. A more efficient involves an environment model, where variable values are evaluated and stored in an environment when bound and looked-up when encountered.

(Is evaluation with substitution considered normal order evaluation? This seems similar to normal/applicative order evaluation described in \href{https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.5}{SICP 1.1.5}.)

\section{Overview}

The irreducible judgment (for internal expressions) in Hazel is not $d\textsf{ val}$, but rather $E\vdash d\textsf{ final}$. Thus, final expressions evaluate to themselves. Variables evaluate to the final value that they are bound to (assuming they are bound; otherwise they are free and thus final). Lambdas evaluate to a closure type. The evaluation of a let-expression or function application extends the current environment with the newly-bound variable. For function applications, the current environment is first extended with the closure environment before binding the new variable. When extending an environment ($E::E'$ or $E,x\leftarrow d$), bindings on the right overwrite bindings on the left. The following metatheorem states that environments only include final terms.
\begin{theorem}
  If the variable binding $x\leftarrow d$ exists in $E$, then $d\textsf{ final}$.
\end{theorem}
This can be proved by induction on an empty environment by observing that all terms added to an environment must be final.

\clearpage{}
\section*{Big-step semantics}

The judgment rules for evaluating variables, lambdas (which evaluate to closures), function application, \texttt{let}-expressions (very similar to function application), and a sample binary operator are shown. \\

\judgbox{E\vdash d\Downarrow d'}{Internal expression $d$ evaluates to $d'$ given environment $E$}

\begin{mathpar}
  \Infer{EvalB-Final}{E\vdash d\textsf{ final}}{E\vdash d\Downarrow d}
  \and
  \Infer{EvalB-Var}{}{E,x\leftarrow d\vdash x\Downarrow d}
  \and
  \Infer{EvalB-Lam}{}{E\vdash(\lambda x:\tau.d)\Downarrow [E](\lambda x:\tau.d)}
  \and
  \Infer{EvalB-Ap}{
    E\vdash d_2\Downarrow d_2' \\
    E::E',x\leftarrow d_2'\vdash d_1\Downarrow d
  }{E\vdash[E'](\lambda x:\tau.d_1)(d_2)\Downarrow d}
  \and
  \Infer{EvalB-Let}{
    E\vdash d_2\Downarrow d_2' \\
    E,x\leftarrow d_2'\vdash d_1\Downarrow d
  }{E\vdash\texttt{let }x=d_2\texttt{ in }d_1\Downarrow d}
  \and
  \Infer{EvalB-Op}{
    E\vdash d_1\Downarrow d_1' \\
    E\vdash d_2\Downarrow d_2'
  }{E\vdash d_1+d_2\Downarrow d_1'+d_2'}
\end{mathpar}

\clearpage{}
\section*{Small-step semantics}

The small-step evaluation judgments equivalent to the above big-step judgments are shown below. \\

\judgbox{E\vdash d\to d'}{Internal expression $d$ takes an instruction transition to $d'$ \\ given environment $E$}

\begin{mathpar}
  \Infer{EvalS-Var}{}{E,x\leftarrow d\vdash x\to d}
  \and
  \Infer{EvalS-Lam}{}{E\vdash(\lambda x:\tau.d)\to ([E]\lambda x:\tau.d)}
  \and
  \Infer{EvalS-Ap$_1$}{E\vdash d_1\to d_1'}{E\vdash d_1(d_2)\to d_1'(d_2)}
  \and
  \Infer{EvalS-Ap$_2$}{E\vdash d_2\to d_2'}{E\vdash d_1(d_2)\to d_1(d_2')}
  \and
  \Infer{EvalS-Ap$_3$}{
    E\vdash d_2\textsf{ final} \\
    E::E'::x\leftarrow d_2\vdash d_1\to d_1'
  }{E\vdash ([E']\lambda x:\tau.d_1)(d_2)\to ([E']\lambda x:\tau.d_1')(d_2)}
  \and
  \Infer{EvalS-Ap$_4$}{
    E\vdash d_2\textsf{ final} \\
    E::E'::x\leftarrow d_2\vdash d_1\textsf{ final}
  }{E\vdash([E']\lambda x:\tau.d_1)(d_2)\to d_1}
  \and
  \Infer{EvalS-Let$_1$}{
    E\vdash d_2\to d_2'
  }{E\vdash\texttt{let }x=d_2\texttt{ in }d_1\to\texttt{let }x=d_2'\texttt{ in }d_1}
  \and
  \Infer{EvalS-Let$_2$}{
    E\vdash d_2\textsf{ final} \\
    E,x\leftarrow d_2\vdash d_1\to d_1'
  }{E\vdash\texttt{let }x=d_2\texttt{ in }d_1\to\texttt{let }x=d_2\texttt{ in }d_1'}
  \and
  \Infer{EvalS-Let$_3$}{
    E\vdash d_2\textsf{ final} \\
    E,x\leftarrow d_2\vdash d_1\textsf{ final}
  }{E\vdash\texttt{let }x=d_2\texttt{ in }d_1\to d_1}
  \and
  \Infer{EvalS-Op$_1$}{E\vdash d_1\to d_1'}{E\vdash d_1+d_2\to d_1'+d_2}
  \and
  \Infer{EvalS-Op$_2$}{E\vdash d_2\to d_2'}{E\vdash d_1+d_2\to d_1+d_2'}
  \and
  \Infer{EvalS-Op$_3$}{}{E\vdash\hnum{n_1}+\hnum{n_2}\to\hnum{n_1+n_2}}
\end{mathpar}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
